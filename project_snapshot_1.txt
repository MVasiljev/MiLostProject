# Project File Structure

ðŸ“„ base_renderer.rs
ðŸ“„ font.rs
ðŸ“„ types.rs
ðŸ“„ renderer.rs
ðŸ“„ registry.rs
ðŸ“„ edge_insets.rs
ðŸ“„ layout_info.rs
ðŸ“„ event_handler.rs
ðŸ“„ color.rs
ðŸ“„ properties.rs
ðŸ“„ property.rs
ðŸ“„ base_props.rs
ðŸ“„ layout_utils.rs
ðŸ“„ event_system.rs
ðŸ“„ event_types.rs
ðŸ“„ node.rs
ðŸ“„ component.rs
ðŸ“„ event_middleware.rs
ðŸ“„ layout_engine.rs
ðŸ“„ gesture_recognition.rs
ðŸ“„ styles.rs
ðŸ“„ shared.rs

# Project File Contents


## File: base_renderer.rs

```rs
use crate::render::renderer::{DrawingContext, ComponentRenderer};
use crate::render::node::RenderNode;
use crate::layout::Rect;
use crate::shared::color::Color;
use crate::shared::edge_insets::EdgeInsets;

/// Handles rendering of common component aspects
pub struct BaseRenderer;

impl BaseRenderer {
    /// Draw background, border, and shadow for a component
    pub fn draw_background_and_borders<T: DrawingContext>(
        context: &T,
        node: &RenderNode,
        frame: Rect
    ) -> Result<(), String> {
        // Apply shadow if defined
        let shadow_applied = Self::apply_shadow(context, node, frame)?;
        
        // Draw background
        Self::draw_background(context, node, frame)?;
        
        // Draw border
        Self::draw_border(context, node, frame)?;
        
        // Clear shadow if it was applied
        if shadow_applied {
            context.clear_shadow()?;
        }
        
        Ok(())
    }
    
    /// Apply shadow to a component
    pub fn apply_shadow<T: DrawingContext>(
        context: &T,
        node: &RenderNode,
        frame: Rect
    ) -> Result<bool, String> {
        if let (Some(shadow_radius), Some(shadow_color)) = (
            node.get_prop_f32("shadow_radius"),
            node.get_prop_string("shadow_color")
        ) {
            let shadow_offset_x = node.get_prop_f32("shadow_offset_x").unwrap_or(0.0);
            let shadow_offset_y = node.get_prop_f32("shadow_offset_y").unwrap_or(0.0);
            
            context.set_shadow(shadow_offset_x, shadow_offset_y, shadow_radius, shadow_color)?;
            Ok(true)
        } else {
            Ok(false)
        }
    }
    
    /// Draw the background of a component
    pub fn draw_background<T: DrawingContext>(
        context: &T,
        node: &RenderNode,
        frame: Rect
    ) -> Result<(), String> {
        if let Some(background) = node.get_prop_string("background") {
            let border_radius = node.get_prop_f32("border_radius").unwrap_or(0.0);
            
            context.begin_path()?;
            
            if border_radius > 0.0 {
                Self::draw_rounded_rect(context, frame.x, frame.y, frame.width, frame.height, border_radius)?;
            } else {
                context.rect(frame.x, frame.y, frame.width, frame.height)?;
            }
            
            // Check for gradient
            if let Some(gradient_type) = node.get_prop_string("gradient_type") {
                // Use Self instead of self since this is a static method
                Self::apply_gradient(context, node, frame, &gradient_type)?;
            } else {
                context.set_fill_color(&background)?;
            }
            
            context.fill()?;
        }
        
        Ok(())
    }
    
    /// Draw the border of a component
    pub fn draw_border<T: DrawingContext>(
        context: &T,
        node: &RenderNode,
        frame: Rect
    ) -> Result<(), String> {
        if let Some(border_width) = node.get_prop_f32("border_width") {
            if border_width <= 0.0 {
                return Ok(());
            }
            
            if let Some(border_color) = node.get_prop_string("border_color") {
                let border_radius = node.get_prop_f32("border_radius").unwrap_or(0.0);
                
                context.begin_path()?;
                
                if border_radius > 0.0 {
                    Self::draw_rounded_rect(context, frame.x, frame.y, frame.width, frame.height, border_radius)?;
                } else {
                    context.rect(frame.x, frame.y, frame.width, frame.height)?;
                }
                
                context.set_stroke_color(&border_color)?;
                context.set_line_width(border_width)?;
                
                // Check for dash pattern
                if let Some(border_style) = node.get_prop_string("border_style") {
                    match border_style.to_lowercase().as_str() {
                        "dashed" => {
                            // Set dash pattern (5px dash, 3px gap)
                            // This would need proper DrawingContext support
                            // context.set_line_dash(&[5.0, 3.0])?;
                        },
                        "dotted" => {
                            // Set dot pattern (1px dash, 2px gap)
                            // This would need proper DrawingContext support
                            // context.set_line_dash(&[1.0, 2.0])?;
                        },
                        _ => {} // Solid or none
                    }
                }
                
                context.stroke()?;
            }
        }
        
        Ok(())
    }
    
    /// Draw a rounded rectangle
    pub fn draw_rounded_rect<T: DrawingContext>(
        context: &T,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        radius: f32
    ) -> Result<(), String> {
        let r = radius.min(width / 2.0).min(height / 2.0);
        
        context.move_to(x + r, y)?;
        context.line_to(x + width - r, y)?;
        context.arc(x + width - r, y + r, r, -std::f32::consts::FRAC_PI_2, 0.0, false)?;
        context.line_to(x + width, y + height - r)?;
        context.arc(x + width - r, y + height - r, r, 0.0, std::f32::consts::FRAC_PI_2, false)?;
        context.line_to(x + r, y + height)?;
        context.arc(x + r, y + height - r, r, std::f32::consts::FRAC_PI_2, std::f32::consts::PI, false)?;
        context.line_to(x, y + r)?;
        context.arc(x + r, y + r, r, std::f32::consts::PI, -std::f32::consts::FRAC_PI_2, false)?;
        
        Ok(())
    }
    
    /// Apply a gradient to the context
    pub fn apply_gradient<T: DrawingContext>(
        context: &T,
        node: &RenderNode,
        frame: Rect,
        gradient_type: &str
    ) -> Result<(), String> {
        let stop_count = node.get_prop_string("gradient_stop_count")
            .and_then(|s| s.parse::<usize>().ok())
            .unwrap_or(0);
            
        if stop_count == 0 {
            return Ok(());
        }
        
        // Collect gradient stops
        let mut stops = Vec::with_capacity(stop_count);
        
        for i in 0..stop_count {
            if let (Some(color), Some(position_str)) = (
                node.get_prop_string(&format!("gradient_stop_{}_color", i)),
                node.get_prop_string(&format!("gradient_stop_{}_position", i))
            ) {
                if let Ok(position) = position_str.parse::<f32>() {
                    stops.push((position, color.clone()));
                }
            }
        }
        
        if stops.is_empty() {
            return Ok(());
        }
        
        // Create gradient based on type
        let gradient_id = match gradient_type.to_lowercase().as_str() {
            "linear" => {
                let start_x = node.get_prop_f32("gradient_start_x").unwrap_or(frame.x);
                let start_y = node.get_prop_f32("gradient_start_y").unwrap_or(frame.y);
                let end_x = node.get_prop_f32("gradient_end_x").unwrap_or(frame.x + frame.width);
                let end_y = node.get_prop_f32("gradient_end_y").unwrap_or(frame.y + frame.height);
                
                context.create_linear_gradient(start_x, start_y, end_x, end_y, stops)?
            },
            "radial" => {
                let center_x = node.get_prop_f32("gradient_start_x").unwrap_or(frame.x + frame.width / 2.0);
                let center_y = node.get_prop_f32("gradient_start_y").unwrap_or(frame.y + frame.height / 2.0);
                let radius = node.get_prop_f32("gradient_radius")
                    .unwrap_or((frame.width.powi(2) + frame.height.powi(2)).sqrt() / 2.0);
                
                context.create_radial_gradient(center_x, center_y, 0.0, center_x, center_y, radius, stops)?
            },
            _ => {
                // Unsupported gradient type, use linear as fallback
                let start_x = frame.x;
                let start_y = frame.y;
                let end_x = frame.x + frame.width;
                let end_y = frame.y + frame.height;
                
                context.create_linear_gradient(start_x, start_y, end_x, end_y, stops)?
            }
        };
        
        context.set_fill_gradient(&gradient_id)?;
        
        Ok(())
    }
    
    /// Parse edge insets from a node
    pub fn parse_edge_insets(node: &RenderNode) -> EdgeInsets {
        if let Some(insets_str) = node.get_prop_string("edge_insets") {
            if let Some(insets) = crate::shared::edge_insets::parse_edge_insets(&insets_str) {
                return insets;
            }
        }
        
        if let Some(padding) = node.get_prop_f32("padding") {
            EdgeInsets::all(padding)
        } else {
            EdgeInsets::zero()
        }
    }
    
    /// Parse color from a node property
    pub fn parse_color(value: &str) -> String {
        // For now, just return the value as-is
        // In a more complete implementation, this would handle color names, etc.
        value.to_string()
    }
}

/// Basic renderer implementation for container components
pub struct BaseContainerRenderer;

impl<T: DrawingContext> ComponentRenderer<T> for BaseContainerRenderer {
    fn render(&self, node: &RenderNode, context: &T, frame: Rect) -> Result<(), String> {
        // Draw background, border, and shadow
        BaseRenderer::draw_background_and_borders(context, node, frame)?;
        
        // Children are rendered by the main renderer
        
        Ok(())
    }
```

## File: font.rs

```rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum FontWeight {
    Thin,
    ExtraLight,
    Light,
    Regular,
    Medium,
    SemiBold,
    Bold,
    ExtraBold,
    Black,
    Custom(u16),
}

impl FontWeight {
    pub fn to_css_weight(&self) -> String {
        match self {
            FontWeight::Thin => "100".to_string(),
            FontWeight::ExtraLight => "200".to_string(), 
            FontWeight::Light => "300".to_string(),
            FontWeight::Regular => "400".to_string(),
            FontWeight::Medium => "500".to_string(),
            FontWeight::SemiBold => "600".to_string(),
            FontWeight::Bold => "700".to_string(),
            FontWeight::ExtraBold => "800".to_string(),
            FontWeight::Black => "900".to_string(),
            FontWeight::Custom(weight) => weight.to_string(),
        }
    }
    
    pub fn value(&self) -> u16 {
        match self {
            FontWeight::Thin => 100,
            FontWeight::ExtraLight => 200,
            FontWeight::Light => 300,
            FontWeight::Regular => 400,
            FontWeight::Medium => 500,
            FontWeight::SemiBold => 600,
            FontWeight::Bold => 700,
            FontWeight::ExtraBold => 800,
            FontWeight::Black => 900,
            FontWeight::Custom(weight) => *weight,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum FontWidth {
    UltraCondensed,
    ExtraCondensed,
    Condensed,
    SemiCondensed,
    Normal,
    SemiExpanded,
    Expanded,
    ExtraExpanded,
    UltraExpanded,
}

impl FontWidth {
    pub fn to_css_stretch(&self) -> String {
        match self {
            FontWidth::UltraCondensed => "ultra-condensed".to_string(),
            FontWidth::ExtraCondensed => "extra-condensed".to_string(),
            FontWidth::Condensed => "condensed".to_string(),
            FontWidth::SemiCondensed => "semi-condensed".to_string(),
            FontWidth::Normal => "normal".to_string(),
            FontWidth::SemiExpanded => "semi-expanded".to_string(),
            FontWidth::Expanded => "expanded".to_string(),
            FontWidth::ExtraExpanded => "extra-expanded".to_string(),
            FontWidth::UltraExpanded => "ultra-expanded".to_string(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum FontSlant {
    Normal,
    Italic,
    Oblique,
}

impl FontSlant {
    pub fn to_css_style(&self) -> String {
        match self {
            FontSlant::Normal => "normal".to_string(),
            FontSlant::Italic => "italic".to_string(),
            FontSlant::Oblique => "oblique".to_string(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum TextCapitalization {
    None,
    Words,
    Sentences,
    Characters,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum TextBaseline {
    Alphabetic,
    Ideographic,
    Top,
    Bottom,
    Middle,
    Hanging,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FontFeatures {
    pub liga: Option<bool>,
    pub dlig: Option<bool>,
    pub hlig: Option<bool>,
    pub calt: Option<bool>,
    pub swsh: Option<bool>,
    pub kern: Option<bool>,
    pub smcp: Option<bool>,
    pub c2sc: Option<bool>,
    pub onum: Option<bool>,
    pub tnum: Option<bool>,
    pub zero: Option<bool>,
    pub frac: Option<bool>,
    pub ordn: Option<bool>,
    
    pub custom: Option<HashMap<String, bool>>,
}

impl FontFeatures {
    pub fn new() -> Self {
        Self {
            liga: Some(true),
            dlig: None,
            hlig: None,
            calt: Some(true),
            swsh: None,
            kern: Some(true),
            smcp: None,
            c2sc: None,
            onum: None,
            tnum: None,
            zero: None,
            frac: None,
            ordn: None,
            custom: None,
        }
    }
    
    pub fn to_css_features(&self) -> String {
        let mut features = Vec::new();
        
        if let Some(liga) = self.liga {
            features.push(format!("\"liga\" {}", if liga { 1 } else { 0 }));
        }
        
        if let Some(dlig) = self.dlig {
            features.push(format!("\"dlig\" {}", if dlig { 1 } else { 0 }));
        }
        
        if let Some(hlig) = self.hlig {
            features.push(format!("\"hlig\" {}", if hlig { 1 } else { 0 }));
        }
        
        if let Some(calt) = self.calt {
            features.push(format!("\"calt\" {}", if calt { 1 } else { 0 }));
        }
        
        if let Some(swsh) = self.swsh {
            features.push(format!("\"swsh\" {}", if swsh { 1 } else { 0 }));
        }
        
        if let Some(kern) = self.kern {
            features.push(format!("\"kern\" {}", if kern { 1 } else { 0 }));
        }
        
        if let Some(smcp) = self.smcp {
            features.push(format!("\"smcp\" {}", if smcp { 1 } else { 0 }));
        }
        
        if let Some(c2sc) = self.c2sc {
            features.push(format!("\"c2sc\" {}", if c2sc { 1 } else { 0 }));
        }
        
        if let Some(onum) = self.onum {
            features.push(format!("\"onum\" {}", if onum { 1 } else { 0 }));
        }
        
        if let Some(tnum) = self.tnum {
            features.push(format!("\"tnum\" {}", if tnum { 1 } else { 0 }));
        }
        
        if let Some(zero) = self.zero {
            features.push(format!("\"zero\" {}", if zero { 1 } else { 0 }));
        }
        
        if let Some(frac) = self.frac {
            features.push(format!("\"frac\" {}", if frac { 1 } else { 0 }));
        }
        
        if let Some(ordn) = self.ordn {
            features.push(format!("\"ordn\" {}", if ordn { 1 } else { 0 }));
        }
        
        if let Some(custom) = &self.custom {
            for (feature, value) in custom {
                features.push(format!("\"{}\" {}", feature, if *value { 1 } else { 0 }));
            }
        }
        
        features.join(", ")
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FontDescriptor {
    pub family: String,
    pub weight: Option<FontWeight>,
    pub size: Option<f32>,
    pub slant: Option<FontSlant>,
    pub width: Option<FontWidth>,
    pub line_height: Option<f32>,
    pub letter_spacing: Option<f32>,
    pub features: Option<FontFeatures>,
}

impl FontDescriptor {
    pub fn new(family: impl Into<String>) -> Self {
        Self {
            family: family.into(),
            weight: None,
            size: None,
            slant: None,
            width: None,
            line_height: None,
            letter_spacing: None,
            features: None,
        }
    }
    
    pub fn with_weight(mut self, weight: FontWeight) -> Self {
        self.weight = Some(weight);
        self
    }
    
    pub fn with_size(mut self, size: f32) -> Self {
        self.size = Some(size);
        self
    }
    
    pub fn with_slant(mut self, slant: FontSlant) -> Self {
        self.slant = Some(slant);
        self
    }
    
    pub fn with_width(mut self, width: FontWidth) -> Self {
        self.width = Some(width);
        self
    }
    
    pub fn with_line_height(mut self, line_height: f32) -> Self {
        self.line_height = Some(line_height);
        self
    }
    
    pub fn with_letter_spacing(mut self, letter_spacing: f32) -> Self {
        self.letter_spacing = Some(letter_spacing);
        self
    }
    
    pub fn with_features(mut self, features: FontFeatures) -> Self {
        self.features = Some(features);
        self
    }
    
    pub fn to_css_string(&self) -> String {
        let mut parts = Vec::new();
        
        if let Some(slant) = &self.slant {
            parts.push(slant.to_css_style());
        }
        
        
        if let Some(weight) = &self.weight {
            parts.push(weight.to_css_weight());
        }
        
        
        if let Some(size) = self.size {
            if let Some(line_height) = self.line_height {
                parts.push(format!("{}px/{}em", size, line_height));
            } else {
                parts.push(format!("{}px", size));
            }
        }
        
        parts.push(if self.family.contains(' ') && !self.family.starts_with('"') {
            format!("\"{}\"", self.family)
        } else {
            self.family.clone()
        });
        
        parts.join(" ")
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum SystemFont {
    Default,
    Serif,
    SansSerif,
    Monospace,
    Cursive,
    Fantasy,
    SystemUI,
}

impl SystemFont {
    pub fn to_css_family(&self) -> String {
        match self {
            SystemFont::Default => "sans-serif".to_string(),
            SystemFont::Serif => "serif".to_string(),
            SystemFont::SansSerif => "sans-serif".to_string(),
            SystemFont::Monospace => "monospace".to_string(),
            SystemFont::Cursive => "cursive".to_string(),
            SystemFont::Fantasy => "fantasy".to_string(),
            SystemFont::SystemUI => "system-ui".to_string(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FontFamily {
    pub primary: String,
    pub fallbacks: Vec<String>,
    pub system_fallback: Option<SystemFont>,
}

impl FontFamily {
    pub fn new(primary: impl Into<String>) -> Self {
        Self {
            primary: primary.into(),
            fallbacks: Vec::new(),
            system_fallback: Some(SystemFont::Default),
        }
    }
    
    pub fn add_fallback(mut self, fallback: impl Into<String>) -> Self {
        self.fallbacks.push(fallback.into());
        self
    }
    
    pub fn with_system_fallback(mut self, system_font: SystemFont) -> Self {
        self.system_fallback = Some(system_font);
        self
    }
    
    pub fn to_css_string(&self) -> String {
        let mut families = Vec::new();
        
        if self.primary.contains(' ') && !self.primary.starts_with('"') {
            families.push(format!("\"{}\"", self.primary));
        } else {
            families.push(self.primary.clone());
        }
        
        for fallback in &self.fallbacks {
            if fallback.contains(' ') && !fallback.starts_with('"') {
                families.push(format!("\"{}\"", fallback));
            } else {
                families.push(fallback.clone());
            }
        }
        
        if let Some(system) = &self.system_fallback {
            families.push(system.to_css_family());
        }
        
        families.join(", ")
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum FontStyle {
    LargeTitle,
    Title1,
    Title2,
    Title3,
    
    Headline,
    Subheadline,
    Body,
    Callout,
    Caption1,
    Caption2,
    Footnote,
    
    Code,
    Button,
    Link,
    
    Title,
    Caption,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct TextStyle {
    pub font: FontDescriptor,
    pub line_spacing: Option<f32>,
    pub paragraph_spacing: Option<f32>,
    pub text_case: Option<TextCapitalization>,
    pub baseline: Option<TextBaseline>,
}

impl TextStyle {
    pub fn new(font: FontDescriptor) -> Self {
        Self {
            font,
            line_spacing: None,
            paragraph_spacing: None,
            text_case: None,
            baseline: None,
        }
    }
    
    pub fn with_line_spacing(mut self, spacing: f32) -> Self {
        self.line_spacing = Some(spacing);
        self
    }
    
    pub fn with_paragraph_spacing(mut self, spacing: f32) -> Self {
        self.paragraph_spacing = Some(spacing);
        self
    }
    
    pub fn with_text_case(mut self, case: TextCapitalization) -> Self {
        self.text_case = Some(case);
        self
    }
    
    pub fn with_baseline(mut self, baseline: TextBaseline) -> Self {
        self.baseline = Some(baseline);
        self
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Typography {
    pub large_title: TextStyle,
    pub title1: TextStyle,
    pub title2: TextStyle,
    pub title3: TextStyle,
    pub headline: TextStyle,
    pub subheadline: TextStyle,
    pub body: TextStyle,
    pub callout: TextStyle,
    pub caption1: TextStyle,
    pub caption2: TextStyle,
    pub footnote: TextStyle,
    pub code: TextStyle,
    pub button: TextStyle,
    pub link: TextStyle,
    
    pub custom_styles: HashMap<String, TextStyle>,
    
    pub text_size_adjustment: f32,
}

impl Typography {
    pub fn get_style(&self, style: &FontStyle) -> &TextStyle {
        match style {
            FontStyle::LargeTitle => &self.large_title,
            FontStyle::Title1 => &self.title1,
            FontStyle::Title2 => &self.title2,
            FontStyle::Title3 => &self.title3,
            FontStyle::Headline => &self.headline,
            FontStyle::Subheadline => &self.subheadline,
            FontStyle::Body => &self.body,
            FontStyle::Callout => &self.callout,
            FontStyle::Caption1 => &self.caption1,
            FontStyle::Caption2 => &self.caption2,
            FontStyle::Footnote => &self.footnote,
            FontStyle::Code => &self.code,
            FontStyle::Button => &self.button,
            FontStyle::Link => &self.link,
            
            FontStyle::Title => &self.title1,
            FontStyle::Caption => &self.caption1,
        }
    }
    
    pub fn get_custom_style(&self, name: &str) -> Option<&TextStyle> {
        self.custom_styles.get(name)
    }
    
    pub fn register_custom_style(&mut self, name: impl Into<String>, style: TextStyle) {
        self.custom_styles.insert(name.into(), style);
    }
    
    pub fn set_text_size_adjustment(&mut self, adjustment: f32) {
        self.text_size_adjustment = adjustment;
    }
    
    pub fn scale_font_size(&self, base_size: f32) -> f32 {
        base_size * self.text_size_adjustment
    }
}

impl Default for Typography {
    fn default() -> Self {
        let sans_serif = FontFamily::new("Inter")
            .add_fallback("Roboto")
            .add_fallback("Segoe UI")
            .add_fallback("Helvetica Neue")
            .add_fallback("Helvetica")
            .add_fallback("Arial")
            .with_system_fallback(SystemFont::SansSerif);
        
        let sans_serif_family = sans_serif.to_css_string();
        
        let monospace = FontFamily::new("JetBrains Mono")
            .add_fallback("Menlo")
            .add_fallback("Consolas")
            .add_fallback("Monaco")
            .add_fallback("Courier New")
            .with_system_fallback(SystemFont::Monospace);
            
        let monospace_family = monospace.to_css_string();
        
        Self {
            large_title: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Bold)
                    .with_size(34.0)
                    .with_line_height(1.2)
            ),
            title1: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Bold)
                    .with_size(28.0)
                    .with_line_height(1.2)
            ),
            title2: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Bold)
                    .with_size(22.0)
                    .with_line_height(1.2)
            ),
            title3: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::SemiBold)
                    .with_size(20.0)
                    .with_line_height(1.2)
            ),
            headline: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::SemiBold)
                    .with_size(17.0)
                    .with_line_height(1.3)
            ),
            subheadline: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Medium)
                    .with_size(15.0)
                    .with_line_height(1.3)
            ),
            body: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(17.0)
                    .with_line_height(1.4)
            ),
            callout: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(16.0)
                    .with_line_height(1.4)
            ),
            caption1: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(12.0)
                    .with_line_height(1.3)
            ),
            caption2: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(11.0)
                    .with_line_height(1.3)
            ),
            footnote: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(13.0)
                    .with_line_height(1.2)
            ),
            code: TextStyle::new(
                FontDescriptor::new(monospace_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(15.0)
                    .with_line_height(1.5)
            ),
            button: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Medium)
                    .with_size(16.0)
                    .with_line_height(1.2)
            ),
            link: TextStyle::new(
                FontDescriptor::new(sans_serif_family.clone())
                    .with_weight(FontWeight::Regular)
                    .with_size(17.0)
                    .with_line_height(1.4)
            ),
            custom_styles: HashMap::new(),
            text_size_adjustment: 1.0,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FontTheme {
    pub primary_font: FontFamily,
    pub heading_font: Option<FontFamily>,
    pub code_font: FontFamily,
    pub typography: Typography,
}

impl Default for FontTheme {
    fn default() -> Self {
        let sans_serif = FontFamily::new("Inter")
            .add_fallback("Roboto")
            .add_fallback("Segoe UI")
            .add_fallback("Helvetica Neue")
            .add_fallback("Helvetica")
            .add_fallback("Arial")
            .with_system_fallback(SystemFont::SansSerif);
        
        let monospace = FontFamily::new("JetBrains Mono")
            .add_fallback("Menlo")
            .add_fallback("Consolas")
            .add_fallback("Monaco")
            .add_fallback("Courier New")
            .with_system_fallback(SystemFont::Monospace);
            
        Self {
            primary_font: sans_serif.clone(),
            heading_font: None,
            code_font: monospace,
            typography: Typography::default(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
#[serde(rename_all = "camelCase")]
pub struct FontRegistry {
    pub registered_fonts: HashMap<String, Vec<String>>,
}

impl FontRegistry {
    pub fn new() -> Self {
        Self {
            registered_fonts: HashMap::new(),
        }
    }
    
    pub fn register_font(&mut self, name: impl Into<String>, sources: Vec<String>) {
        self.registered_fonts.insert(name.into(), sources);
    }
    
    pub fn get_font_face_css(&self) -> String {
        let mut css = String::new();
        
        for (font_name, sources) in &self.registered_fonts {
            for source in sources {
                let format = if source.ends_with(".woff2") {
                    "woff2"
                } else if source.ends_with(".woff") {
                    "woff"
                } else if source.ends_with(".ttf") {
                    "truetype"
                } else if source.ends_with(".otf") {
                    "opentype"
                } else {
                    "auto"
                };
                
                css.push_str(&format!(
                    "@font-face {{
  font-family: \"{}\";
  src: url(\"{}\") format(\"{}\");
  font-display: swap;
}}

",
                    font_name, source, format
                ));
            }
        }
        
        css
    }
}

pub mod font_presets {
    use super::*;
    
    pub fn minimalist() -> FontTheme {
        FontTheme::default()
    }
    
    pub fn classic_serif() -> FontTheme {
        let serif = FontFamily::new("Georgia")
            .add_fallback("Times New Roman")
            .add_fallback("Times")
            .with_system_fallback(SystemFont::Serif);
            
        let serif_family = serif.to_css_string();
        
        let sans_serif = FontFamily::new("Helvetica Neue")
            .add_fallback("Arial")
            .add_fallback("Segoe UI")
            .with_system_fallback(SystemFont::SansSerif);
            
        let monospace = FontFamily::new("Consolas")
            .add_fallback("Monaco")
            .add_fallback("Courier New")
            .with_system_fallback(SystemFont::Monospace);
            
        let mono_family = monospace.to_css_string();
        
        let mut typography = Typography::default();
        
        typography.large_title = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::Bold)
                .with_size(36.0)
                .with_line_height(1.2)
        );
        
        typography.title1 = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::Bold)
                .with_size(30.0)
                .with_line_height(1.2)
        );
        
        typography.title2 = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::Bold)
                .with_size(24.0)
                .with_line_height(1.2)
        );
        
        typography.title3 = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::SemiBold)
                .with_size(22.0)
                .with_line_height(1.25)
        );
        
        typography.headline = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::SemiBold)
                .with_size(18.0)
                .with_line_height(1.3)
        );
        
        typography.subheadline = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::Medium)
                .with_size(16.0)
                .with_line_height(1.3)
        );
        
        typography.body = TextStyle::new(
            FontDescriptor::new(serif_family.clone())
                .with_weight(FontWeight::Regular)
                .with_size(18.0)
                .with_line_height(1.5)
        );
        
        typography.code = TextStyle::new(
            FontDescriptor::new(mono_family)
                .with_weight(FontWeight::Regular)
                .with_size(16.0)
                .with_line_height(1.5)
        );
        
        FontTheme {
            primary_font: serif,
            heading_font: None,
            code_font: monospace,
            typography,
        }
    }
    
    pub fn modern_geometric() -> FontTheme {
        let geometric = FontFamily::new("Futura")
            .add_fallback("Century Gothic")
            .add_fallback("Avenir")
            .add_fallback("Proxima Nova")
            .with_system_fallback(SystemFont::SansSerif);
            
        let geo_family = geometric.to_css_string();
        
        let monospace = FontFamily::new("IBM Plex Mono")
            .add_fallback("Fira Code")
            .add_fallback("Source Code Pro")
            .with_system_fallback(SystemFont::Monospace);
            
        let mono_family = monospace.to_css_string();
        
        let mut typography = Typography::default();
        
        typography.large_title = TextStyle::new(
            FontDescriptor::new(geo_family.clone())
                .with_weight(FontWeight::Light)
                .with_size(40.0)
                .with_line_height(1.1)
                .with_letter_spacing(0.2)
        );
        
        typography.title1 = TextStyle::new(
            FontDescriptor::new(geo_family.clone())
                .with_weight(FontWeight::Light)
                .with_size(32.0)
                .with_line_height(1.1)
                .with_letter_spacing(0.2)
        );
        
        typography.title2 = TextStyle::new(
            FontDescriptor::new(geo_family.clone())
                .with_weight(FontWeight::Medium)
                .with_size(24.0)
                .with_line_height(1.2)
                .with_letter_spacing(0.15)
        );
        
        typography.title3 = TextStyle::new(
            FontDescriptor::new(geo_family.clone())
                .with_weight(FontWeight::Medium)
                .with_size(20.0)
                .with_line_height(1.2)
                .with_letter_spacing(0.1)
        );
        
        typography.headline = TextStyle::new(
            FontDescriptor::new(geo_family.clone())
                .with_weight(FontWeight::Medium)
                .with_size(18.0)
                .with_line_height(1.3)
        );
        
        typography.body = TextStyle::new(
            FontDescriptor::new(geo_family.clone())
                .with_weight(FontWeight::Regular)
                .with_size(16.0)
                .with_line_height(1.5)
                .with_letter_spacing(0.05)
        );
        
        typography.code = TextStyle::new(
            FontDescriptor::new(mono_family)
                .with_weight(FontWeight::Regular)
                .with_size(15.0)
                .with_line_height(1.5)
        );
        
        FontTheme {
            primary_font: geometric,
            heading_font: None,
            code_font: monospace,
            typography,
        }
    }
    
    pub fn accessibility_focused() -> FontTheme {
        let accessible = FontFamily::new("Atkinson Hyperlegible")
            .add_fallback("Open Sans")
            .add_fallback("Verdana")
            .add_fallback("Arial")
            .with_system_fallback(SystemFont::SansSerif);
            
        let access_family = accessible.to_css_string();
        
        let monospace = FontFamily::new("Fira Code")
            .add_fallback("Consolas")
            .add_fallback("Courier New")
            .with_system_fallback(SystemFont::Monospace);
            
        let mono_family = monospace.to_css_string();
        
        let mut typography = Typography::default();
        
        let accessible_features = FontFeatures {
            liga: Some(true),
            kern: Some(true),
            tnum: Some(true),
            zero: Some(true),
            ..FontFeatures::new()
        };
        
        typography.large_title = TextStyle::new(
            FontDescriptor::new(access_family.clone())
                .with_weight(FontWeight::Bold)
                .with_size(38.0)
                .with_line_height(1.3)
                .with_letter_spacing(0.1)
                .with_features(accessible_features.clone())
        );
        
        typography.title1 = TextStyle::new(
            FontDescriptor::new(access_family.clone())
                .with_weight(FontWeight::Bold)
                .with_size(32.0)
                .with_line_height(1.3)
                .with_letter_spacing(0.1)
                .with_features(accessible_features.clone())
        );
        
        typography.title2 = TextStyle::new(
            FontDescriptor::new(access_family.clone())
                .with_weight(FontWeight::Bold)
                .with_size(26.0)
                .with_line_height(1.3)
                .with_letter_spacing(0.05)
                .with_features(accessible_features.clone())
        );
        
        typography.body = TextStyle::new(
            FontDescriptor::new(access_family.clone())
                .with_weight(FontWeight::Regular)
                .with_size(18.0)
                .with_line_height(1.6)
                .with_letter_spacing(0.05)
                .with_features(accessible_features.clone())
        );
        
        typography.code = TextStyle::new(
            FontDescriptor::new(mono_family)
                .with_weight(FontWeight::Regular)
                .with_size(18.0)
                .with_line_height(1.6)
                .with_features(accessible_features.clone())
        );
        
        typography.text_size_adjustment = 1.1;
        
        FontTheme {
            primary_font: accessible,
            heading_font: None,
            code_font: monospace,
            typography,
        }
    }
```

## File: types.rs

```rs

use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub struct Rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}

impl Rect {
    pub fn new(x: f32, y: f32, width: f32, height: f32) -> Self {
        Self { x, y, width, height }
    }

    pub fn zero() -> Self {
        Self::new(0.0, 0.0, 0.0, 0.0)
    }

    pub fn from_size(width: f32, height: f32) -> Self {
        Self::new(0.0, 0.0, width, height)
    }
    
    pub fn right(&self) -> f32 {
        self.x + self.width
    }
    
    pub fn bottom(&self) -> f32 {
        self.y + self.height
    }
    
    pub fn center(&self) -> Point {
        Point::new(self.x + self.width / 2.0, self.y + self.height / 2.0)
    }
    
    pub fn contains(&self, point: Point) -> bool {
        point.x >= self.x && 
        point.x <= self.right() && 
        point.y >= self.y && 
        point.y <= self.bottom()
    }
    
    pub fn inset(&self, amount: f32) -> Self {
        Self::new(
            self.x + amount,
            self.y + amount,
            (self.width - amount * 2.0).max(0.0),
            (self.height - amount * 2.0).max(0.0),
        )
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

impl Size {
    pub fn new(width: f32, height: f32) -> Self {
        Self { width, height }
    }

    pub fn zero() -> Self {
        Self::new(0.0, 0.0)
    }
    
    pub fn square(size: f32) -> Self {
        Self::new(size, size)
    }
    
    pub fn is_empty(&self) -> bool {
        self.width <= 0.0 || self.height <= 0.0
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub struct Point {
    pub x: f32,
    pub y: f32,
}

impl Point {
    pub fn new(x: f32, y: f32) -> Self {
        Self { x, y }
    }

    pub fn zero() -> Self {
        Self::new(0.0, 0.0)
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum Alignment {
    TopLeading,
    Top,
    TopTrailing,
    Leading,
    Center,
    Trailing,
    BottomLeading,
    Bottom,
    BottomTrailing,
}

impl Default for Alignment {
    fn default() -> Self {
        Alignment::Center
    }
}

impl Alignment {
    pub fn get_point(&self, rect: &Rect) -> Point {
        match self {
            Alignment::TopLeading => Point::new(rect.x, rect.y),
            Alignment::Top => Point::new(rect.x + rect.width / 2.0, rect.y),
            Alignment::TopTrailing => Point::new(rect.right(), rect.y),
            Alignment::Leading => Point::new(rect.x, rect.y + rect.height / 2.0),
            Alignment::Center => rect.center(),
            Alignment::Trailing => Point::new(rect.right(), rect.y + rect.height / 2.0),
            Alignment::BottomLeading => Point::new(rect.x, rect.bottom()),
            Alignment::Bottom => Point::new(rect.x + rect.width / 2.0, rect.bottom()),
            Alignment::BottomTrailing => Point::new(rect.right(), rect.bottom()),
        }
    }
```

## File: renderer.rs

```rs
use crate::{events::SwipeDirection, render::node::RenderNode};
use crate::layout::Rect;
use std::collections::HashMap;
use crate::events::{
    Event, EventType, EventDispatcher, HandlerResult, 
    EventMiddlewarePipeline, MiddlewareResult,
    middlewares::LoggingMiddleware, middlewares::LogLevel,
    TypedEventHandler
};
use std::time::Duration;

pub trait DrawingContext {
    fn set_fill_color(&self, color: &str) -> Result<(), String>;
    fn fill_rect(&self, x: f32, y: f32, width: f32, height: f32) -> Result<(), String>;
    fn set_stroke_color(&self, color: &str) -> Result<(), String>;
    fn set_line_width(&self, width: f32) -> Result<(), String>;
    fn stroke_rect(&self, x: f32, y: f32, width: f32, height: f32) -> Result<(), String>;
    
    fn begin_path(&self) -> Result<(), String>;
    fn move_to(&self, x: f32, y: f32) -> Result<(), String>;
    fn line_to(&self, x: f32, y: f32) -> Result<(), String>;
    fn arc(&self, x: f32, y: f32, radius: f32, start_angle: f32, end_angle: f32, counterclockwise: bool) -> Result<(), String>;
    fn bezier_curve_to(&self, cp1x: f32, cp1y: f32, cp2x: f32, cp2y: f32, x: f32, y: f32) -> Result<(), String>;
    fn quadratic_curve_to(&self, cpx: f32, cpy: f32, x: f32, y: f32) -> Result<(), String>;
    fn ellipse(&self, x: f32, y: f32, radius_x: f32, radius_y: f32, rotation: f32, start_angle: f32, end_angle: f32, counterclockwise: bool) -> Result<(), String>;
    fn close_path(&self) -> Result<(), String>;
    fn fill(&self) -> Result<(), String>;
    fn stroke(&self) -> Result<(), String>;
    fn clip(&self) -> Result<(), String>;
    fn rect(&self, x: f32, y: f32, width: f32, height: f32) -> Result<(), String>;
    
    fn set_font(&self, font: &str) -> Result<(), String>;
    fn set_text_align(&self, align: &str) -> Result<(), String>;
    fn set_text_baseline(&self, baseline: &str) -> Result<(), String>;
    fn fill_text(&self, text: &str, x: f32, y: f32) -> Result<(), String>;
    fn stroke_text(&self, text: &str, x: f32, y: f32) -> Result<(), String>;
    fn measure_text(&self, text: &str) -> Result<f32, String>;
    
    fn draw_image(&self, image_id: &str, x: f32, y: f32, width: f32, height: f32) -> Result<(), String>;
    fn draw_image_with_clip(&self, image_id: &str, sx: f32, sy: f32, s_width: f32, s_height: f32, dx: f32, dy: f32, d_width: f32, d_height: f32) -> Result<(), String>;
    
    fn translate(&self, x: f32, y: f32) -> Result<(), String>;
    fn rotate(&self, angle: f32) -> Result<(), String>;
    fn scale(&self, x: f32, y: f32) -> Result<(), String>;
    fn transform(&self, a: f32, b: f32, c: f32, d: f32, e: f32, f: f32) -> Result<(), String>;
    fn reset_transform(&self) -> Result<(), String>;
    
    fn create_linear_gradient(&self, x0: f32, y0: f32, x1: f32, y1: f32, stops: Vec<(f32, String)>) -> Result<String, String>;
    fn create_radial_gradient(&self, x0: f32, y0: f32, r0: f32, x1: f32, y1: f32, r1: f32, stops: Vec<(f32, String)>) -> Result<String, String>;
    fn set_fill_gradient(&self, gradient_id: &str) -> Result<(), String>;
    fn set_stroke_gradient(&self, gradient_id: &str) -> Result<(), String>;
    
    fn set_shadow(&self, offset_x: f32, offset_y: f32, blur: f32, color: &str) -> Result<(), String>;
    fn clear_shadow(&self) -> Result<(), String>;
    
    fn set_global_alpha(&self, alpha: f32) -> Result<(), String>;
    fn set_global_composite_operation(&self, operation: &str) -> Result<(), String>;
    
    fn save_drawing_state(&self) -> Result<(), String>;
    fn restore_drawing_state(&self) -> Result<(), String>;
    fn clear(&self, x: f32, y: f32, width: f32, height: f32) -> Result<(), String>;
    
    fn clear_clip(&self) -> Result<(), String>;
    fn clip_rect(&self, x: f32, y: f32, width: f32, height: f32) -> Result<(), String>;
    fn clip_rounded_rect(&self, x: f32, y: f32, width: f32, height: f32, radius: f32) -> Result<(), String>;
    
    fn set_blend_mode(&self, mode: &str) -> Result<(), String>;
    fn apply_filter(&self, filter: &str) -> Result<(), String>;
    fn clear_filter(&self) -> Result<(), String>;
}

pub trait ComponentRenderer<T: DrawingContext> {
    fn render(&self, node: &RenderNode, context: &T, frame: Rect) -> Result<(), String>;
}

pub struct Renderer<T: DrawingContext> {
    context: T,
    renderers: HashMap<&'static str, Box<dyn ComponentRenderer<T>>>,
    dirty_regions: Vec<Rect>,
    needs_full_render: bool,
    
    event_dispatcher: EventDispatcher,
    event_middleware: EventMiddlewarePipeline,
    
    node_layout_map: HashMap<String, Rect>,
    focused_node_id: Option<String>,
    hovered_node_id: Option<String>,
}

impl<T: DrawingContext> Renderer<T> {
    pub fn new(context: T) -> Self {
        let mut event_middleware = EventMiddlewarePipeline::new(Duration::from_secs(3))
            .with_max_retries(3);
            
        let _ = event_middleware.add_middleware(
            LoggingMiddleware::new(LogLevel::Debug)
        );
        
        let mut renderer = Self {
            context,
            renderers: HashMap::new(),
            dirty_regions: Vec::new(),
            needs_full_render: true,
            
            event_dispatcher: EventDispatcher::new(),
            event_middleware,
            
            node_layout_map: HashMap::new(),
            focused_node_id: None,
            hovered_node_id: None,
        };
        
        renderer.register_component_renderers();
        
        renderer
    }
    
    fn register_component_renderers(&mut self) {
        use crate::render::components::*;
        
        self.register_renderer("VStack", Box::new(VStackRenderer));
        self.register_renderer("HStack", Box::new(HStackRenderer));
        self.register_renderer("ZStack", Box::new(ZStackRenderer));
        self.register_renderer("Text", Box::new(TextRenderer));
        self.register_renderer("Button", Box::new(ButtonRenderer));
        self.register_renderer("Image", Box::new(ImageRenderer));
        self.register_renderer("Scroll", Box::new(ScrollRenderer));
        self.register_renderer("Spacer", Box::new(SpacerRenderer));
        self.register_renderer("Divider", Box::new(DividerRenderer));
    }
    
    pub fn register_renderer(
        &mut self, 
        component_type: &'static str, 
        renderer: Box<dyn ComponentRenderer<T>>
    ) {
        self.renderers.insert(component_type, renderer);
    }
    
    pub fn render(&self, node: &RenderNode) -> Result<(), String> {
        self.render_node(node, false)
    }
    
    pub fn render_with_clipping(&self, node: &RenderNode) -> Result<(), String> {
        self.render_node(node, true)
    }
    
    pub fn mark_dirty(&mut self, region: Rect) {
        self.dirty_regions.push(region);
    }
    
    pub fn mark_all_dirty(&mut self) {
        self.needs_full_render = true;
    }
    
    pub fn render_dirty_regions(&self, node: &RenderNode, container_rect: Rect) -> Result<(), String> {
        if self.needs_full_render {
            return self.render_node(node, true);
        }
        
        for region in &self.dirty_regions {
            if !regions_intersect(*region, container_rect) {
                continue;
            }
            
            self.context.save_drawing_state()?;
            
            self.context.begin_path()?;
            self.context.rect(region.x, region.y, region.width, region.height)?;
            self.context.clip()?;
            
            self.context.clear(region.x, region.y, region.width, region.height)?;
            
            self.render_node_in_region(node, true, *region)?;
            
            self.context.restore_drawing_state()?;
        }
        
        Ok(())
    }
    
    fn render_node_in_region(&self, node: &RenderNode, enable_clipping: bool, region: Rect) -> Result<(), String> {
        let x = node.get_prop_f32("x").unwrap_or(0.0);
        let y = node.get_prop_f32("y").unwrap_or(0.0);
        let width = node.get_prop_f32("width").unwrap_or(0.0);
        let height = node.get_prop_f32("height").unwrap_or(0.0);
        
        let frame = Rect::new(x, y, width, height);
        
        if !regions_intersect(frame, region) {
            return Ok(());
        }
        
        let should_clip = enable_clipping && node.get_prop("clip_to_bounds")
            .map(|v| v.to_string_value() == "true")
            .unwrap_or(false);
        
        if should_clip {
            self.context.save_drawing_state()?;
            self.context.begin_path()?;
            self.context.rect(frame.x, frame.y, frame.width, frame.height)?;
            self.context.clip()?;
        }
        
        if let Some(renderer) = self.renderers.get(node.type_name.as_str()) {
            renderer.render(node, &self.context, frame)?;
        }
        
        for child in &node.children {
            self.render_node_in_region(child, enable_clipping, region)?;
        }
        
        if should_clip {
            self.context.restore_drawing_state()?;
        }
        
        Ok(())
    }
    
    fn render_node(&self, node: &RenderNode, enable_clipping: bool) -> Result<(), String> {
        let x = node.get_prop_f32("x").unwrap_or(0.0);
        let y = node.get_prop_f32("y").unwrap_or(0.0);
        let width = node.get_prop_f32("width").unwrap_or(0.0);
        let height = node.get_prop_f32("height").unwrap_or(0.0);
        
        let frame = Rect::new(x, y, width, height);
        
        unsafe {
            let this = self as *const Self as *mut Self;
            (*this).node_layout_map.insert(node.id.clone(), frame);
        }
        
        let opacity = node.get_prop_f32("opacity");
        let has_opacity = opacity.is_some() && opacity.unwrap() < 1.0;
        
        if has_opacity {
            self.context.save_drawing_state()?;
            self.context.set_global_alpha(opacity.unwrap())?;
        }
        
        let has_shadow = node.get_prop("shadow_radius").is_some() &&
                         node.get_prop("shadow_color").is_some();
        
        if has_shadow {
            let shadow_radius = node.get_prop_f32("shadow_radius").unwrap_or(0.0);
            let default_shadow_color = "rgba(0,0,0,0.5)".to_string();
            let shadow_color = node.get_prop_as_string("shadow_color")
                .unwrap_or_else(|| default_shadow_color);
            
            let shadow_offset_x = node.get_prop_f32("shadow_offset_x").unwrap_or(0.0);
            let shadow_offset_y = node.get_prop_f32("shadow_offset_y").unwrap_or(0.0);
            
            self.context.set_shadow(shadow_offset_x, shadow_offset_y, shadow_radius, &shadow_color)?;
        }
        
        let should_clip = enable_clipping && node.get_prop_bool("clip_to_bounds")
            .unwrap_or(false);
        
        if should_clip {
            self.context.save_drawing_state()?;
            self.context.begin_path()?;
            
            let corner_radius = node.get_prop_f32("border_radius");
            if let Some(radius) = corner_radius {
                if radius > 0.0 {
                    self.context.clip_rounded_rect(frame.x, frame.y, frame.width, frame.height, radius)?;
                } else {
                    self.context.rect(frame.x, frame.y, frame.width, frame.height)?;
                    self.context.clip()?;
                }
            } else {
                self.context.rect(frame.x, frame.y, frame.width, frame.height)?;
                self.context.clip()?;
            }
        }
        
        let blend_mode = node.get_prop_as_string("blend_mode");
        if let Some(mode) = blend_mode {
            self.context.set_blend_mode(&mode)?;
        }
        
        if let Some(renderer) = self.renderers.get(node.type_name.as_str()) {
            renderer.render(node, &self.context, frame)?;
        }
        
        for child in &node.children {
            self.render_node(child, enable_clipping)?;
        }
        
        if should_clip {
            self.context.restore_drawing_state()?;
        }
        
        if has_shadow {
            self.context.clear_shadow()?;
        }
        
        if has_opacity {
            self.context.restore_drawing_state()?;
        }
        
        Ok(())
    }
    
    pub fn clear_dirty_regions(&mut self) {
        self.dirty_regions.clear();
        self.needs_full_render = false;
    }
    
    
    pub fn register_event_handler(&self, event_type: EventType, handler: TypedEventHandler) {
        self.event_dispatcher.register_handler(event_type, handler);
    }
    
    pub fn register_global_handler(&self, handler: TypedEventHandler) {
        self.event_dispatcher.register_global_handler(handler);
    }
    
    pub fn process_event(&mut self, mut event: Event) -> HandlerResult {
        match self.event_middleware.process(&mut event) {
            Ok(MiddlewareResult::Continue) | Ok(MiddlewareResult::Modified) => {
                if event.target_id.is_none() && event.position.is_some() {
                    let position = event.position.unwrap();
                    if let Some(target_id) = self.find_node_at_position(position.0, position.1) {
                        event.target_id = Some(target_id);
                    }
                }
                
                if matches!(event.event_type, EventType::PointerMove) {
                    self.handle_hover_events(&mut event);
                }
                
                if matches!(event.event_type, EventType::Tap) || 
                   matches!(event.event_type, EventType::PointerDown) {
                    self.handle_focus_events(&mut event);
                }
                
                self.event_dispatcher.dispatch(&mut event)
            },
            Ok(MiddlewareResult::Stop) => {
                HandlerResult::Handled
            },
            Err(err) => {
                eprintln!("Error processing event: {:?}", err);
                HandlerResult::Unhandled
            },
            _ => HandlerResult::Unhandled,
        }
    }
    
    pub fn find_node_at_position(&self, x: f32, y: f32) -> Option<String> {
        let mut nodes: Vec<(&String, &Rect)> = self.node_layout_map.iter().collect();
        
        nodes.reverse();
        
        for (node_id, rect) in nodes {
            if rect.contains_point(x, y) {
                return Some(node_id.clone());
            }
        }
        
        None
    }
    
    fn handle_hover_events(&mut self, event: &mut Event) {
        if let Some(position) = event.position {
            let current_hover = self.find_node_at_position(position.0, position.1);
            
            if current_hover != self.hovered_node_id {
                if let Some(prev_id) = &self.hovered_node_id {
                    let mut hover_exit = Event::new(
                        EventType::HoverExit,
                        event.metadata.source.clone()
                    );
                    hover_exit.target_id = Some(prev_id.clone());
                    hover_exit.position = event.position;
                    
                    let _ = self.event_dispatcher.dispatch(&mut hover_exit);
                }
                
                if let Some(new_id) = &current_hover {
                    let mut hover_enter = Event::new(
                        EventType::HoverEnter,
                        event.metadata.source.clone()
                    );
                    hover_enter.target_id = Some(new_id.clone());
                    hover_enter.position = event.position;
                    
                    let _ = self.event_dispatcher.dispatch(&mut hover_enter);
                }
                
                self.hovered_node_id = current_hover;
            }
        }
    }
    
    fn handle_focus_events(&mut self, event: &mut Event) {
        if let Some(target_id) = &event.target_id {
            if self.focused_node_id.as_ref() == Some(target_id) {
                return;
            }
            
            if let Some(prev_id) = &self.focused_node_id {
                let mut blur_event = Event::new(
                    EventType::Blur,
                    event.metadata.source.clone()
                );
                blur_event.target_id = Some(prev_id.clone());
                
                let _ = self.event_dispatcher.dispatch(&mut blur_event);
            }
            
            let mut focus_event = Event::new(
                EventType::Focus,
                event.metadata.source.clone()
            );
            focus_event.target_id = Some(target_id.clone());
            
            let _ = self.event_dispatcher.dispatch(&mut focus_event);
            
            self.focused_node_id = Some(target_id.clone());
        }
    }
    
    pub fn register_handlers_from_tree(&self, root: &RenderNode) {
        self.register_node_handlers(root);
    }
    
    fn register_node_handlers(&self, node: &RenderNode) {
        for handler in &node.event_handlers {
            let handler_id = handler.handler_id.clone();
            let event_type = handler.event_type.clone();
            
            let typed_handler = TypedEventHandler::new(
                &handler_id,
                {
                    let handler_id = handler_id.clone();
                    let event_type_clone = event_type.clone();
                    move |_event: &mut Event| {
                        println!("Handler '{}' called for event type {:?}", handler_id, event_type_clone);
                        HandlerResult::Handled
                    }
                }
            );
            
            self.event_dispatcher.register_handler(event_type, typed_handler);
        }
        
        if let Some(node_events) = node.get_node_events() {
            let create_handler = |handler_id: String, event_desc: String| {
                TypedEventHandler::new(&handler_id, move |event: &mut Event| {
                    println!("{} handler called for node {:?}", event_desc, event.target_id);
                    HandlerResult::Handled
                })
            };
            
            macro_rules! register_event_handler {
                ($event_type:expr, $handler_option:expr, $event_desc:expr) => {
                    if let Some(ref handler_id) = $handler_option {
                        self.event_dispatcher.register_handler(
                            $event_type,
                            create_handler(
                                handler_id.clone(), 
                                $event_desc.to_string()
                            )
                        );
                    }
                };
            }
            
            register_event_handler!(EventType::Tap, node_events.on_tap, "Tap");
            register_event_handler!(EventType::DoubleTap, node_events.on_double_tap, "Double tap");
            register_event_handler!(EventType::LongPress, node_events.on_long_press, "Long press");
            register_event_handler!(EventType::HoverEnter, node_events.on_hover_enter, "Hover enter");
            register_event_handler!(EventType::HoverExit, node_events.on_hover_exit, "Hover exit");
            register_event_handler!(EventType::Focus, node_events.on_focus, "Focus");
            register_event_handler!(EventType::Blur, node_events.on_blur, "Blur");
            
            for (direction, handler_id) in &node_events.on_swipe {
                let direction_str = direction.clone();
                let swipe_direction = match direction_str.as_str() {
                    "left" => SwipeDirection::Left,
                    "right" => SwipeDirection::Right,
                    "up" => SwipeDirection::Up,
                    "down" => SwipeDirection::Down,
                    _ => continue,
                };
                
                self.event_dispatcher.register_handler(
                    EventType::Swipe(swipe_direction),
                    TypedEventHandler::new(handler_id, move |event: &mut Event| {
                        println!("Swipe {} handler called for node {:?}", direction_str, event.target_id);
                        HandlerResult::Handled
                    })
                );
            }
        }
        
        for child in &node.children {
            self.register_node_handlers(child);
        }
    }
}

fn regions_intersect(a: Rect, b: Rect) -> bool {
    !(a.x > b.x + b.width || 
      a.x + a.width < b.x || 
      a.y > b.y + b.height || 
      a.y + a.height < b.y)
}

impl Rect {
    pub fn contains_point(&self, x: f32, y: f32) -> bool {
        x >= self.x && x <= self.x + self.width && 
        y >= self.y && y <= self.y + self.height
    }
```

## File: registry.rs

```rs

use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use crate::render::node::RenderNode;
use crate::UIComponent;
use crate::render::renderer::{ComponentRenderer, DrawingContext};

pub type ComponentTransformerFn = Arc<dyn Fn(&UIComponent) -> RenderNode + Send + Sync>;

pub struct ComponentTransformerRegistry {
    transformers: HashMap<String, ComponentTransformerFn>,
}

impl ComponentTransformerRegistry {
    pub fn new() -> Self {
        Self {
            transformers: HashMap::new(),
        }
    }
    
    pub fn register_transformer<F>(&mut self, component_type: &str, transformer: F) 
    where
        F: Fn(&UIComponent) -> RenderNode + Send + Sync + 'static
    {
        self.transformers.insert(component_type.to_string(), Arc::new(transformer));
    }
    
    pub fn get_transformer(&self, component_type: &str) -> Option<&ComponentTransformerFn> {
        self.transformers.get(component_type)
    }
    
    pub fn has_transformer(&self, component_type: &str) -> bool {
        self.transformers.contains_key(component_type)
    }
    
    pub fn component_types(&self) -> Vec<String> {
        self.transformers.keys().cloned().collect()
    }
    
    pub fn transform(&self, component: &UIComponent) -> Option<RenderNode> {
        let component_type = match component {
            UIComponent::VStack(_) => "VStack",
            UIComponent::HStack(_) => "HStack",
            UIComponent::ZStack(_) => "ZStack",
            UIComponent::Text(_) => "Text",
            UIComponent::Button(_) => "Button",
            UIComponent::Image(_) => "Image",
            UIComponent::Scroll(_) => "Scroll",
            UIComponent::Spacer(_) => "Spacer",
            UIComponent::Divider(_) => "Divider",
        };
        
        self.get_transformer(component_type)
            .map(|transformer| transformer(component))
    }
    
    pub fn register_standard_transformers(&mut self) {
        use crate::render::transformers::*;
        
        self.register_transformer("VStack", |component| {
            if let UIComponent::VStack(props) = component {
                transform_vstack(props)
            } else {
                panic!("Expected VStack component")
            }
        });
        
        self.register_transformer("HStack", |component| {
            if let UIComponent::HStack(props) = component {
                transform_hstack(props)
            } else {
                panic!("Expected HStack component")
            }
        });
        
        self.register_transformer("ZStack", |component| {
            if let UIComponent::ZStack(props) = component {
                transform_zstack(props)
            } else {
                panic!("Expected ZStack component")
            }
        });
        
        self.register_transformer("Text", |component| {
            if let UIComponent::Text(props) = component {
                transform_text(props)
            } else {
                panic!("Expected Text component")
            }
        });
        
        self.register_transformer("Button", |component| {
            if let UIComponent::Button(props) = component {
                transform_button(props)
            } else {
                panic!("Expected Button component")
            }
        });
        
        self.register_transformer("Image", |component| {
            if let UIComponent::Image(props) = component {
                transform_image(props)
            } else {
                panic!("Expected Image component")
            }
        });
        
        self.register_transformer("Scroll", |component| {
            if let UIComponent::Scroll(props) = component {
                transform_scroll(props)
            } else {
                panic!("Expected Scroll component")
            }
        });
        
        self.register_transformer("Spacer", |component| {
            if let UIComponent::Spacer(props) = component {
                transform_spacer(props)
            } else {
                panic!("Expected Spacer component")
            }
        });
        
        self.register_transformer("Divider", |component| {
            if let UIComponent::Divider(props) = component {
                transform_divider(props)
            } else {
                panic!("Expected Divider component")
            }
        });
    }
}

pub struct AnyComponentRenderer<T: DrawingContext> {
    renderer: Arc<dyn ComponentRenderer<T> + Send + Sync>,
}

impl<T: DrawingContext> AnyComponentRenderer<T> {
    pub fn new<R: ComponentRenderer<T> + Send + Sync + 'static>(renderer: R) -> Self {
        Self {
            renderer: Arc::new(renderer),
        }
    }
    
    pub fn get_renderer(&self) -> &dyn ComponentRenderer<T> {
        &*self.renderer
    }
}

pub struct ComponentRendererRegistry<T: DrawingContext> {
    renderers: HashMap<String, AnyComponentRenderer<T>>,
}

impl<T: DrawingContext> ComponentRendererRegistry<T> {
    pub fn new() -> Self {
        Self {
            renderers: HashMap::new(),
        }
    }
    
    pub fn register_renderer<R>(&mut self, component_type: &str, renderer: R)
    where
        R: ComponentRenderer<T> + Send + Sync + 'static
    {
        self.renderers.insert(
            component_type.to_string(), 
            AnyComponentRenderer::new(renderer)
        );
    }
    
    pub fn get_renderer(&self, component_type: &str) -> Option<&dyn ComponentRenderer<T>> {
        self.renderers.get(component_type)
            .map(|wrapper| wrapper.get_renderer())
    }
    
    pub fn has_renderer(&self, component_type: &str) -> bool {
        self.renderers.contains_key(component_type)
    }
    
    pub fn component_types(&self) -> Vec<String> {
        self.renderers.keys().cloned().collect()
    }
    
    pub fn register_standard_renderers(&mut self) 
    where T: 'static
    {
        use crate::render::components::*;
        
        self.register_renderer("VStack", VStackRenderer);
        self.register_renderer("HStack", HStackRenderer);
        self.register_renderer("ZStack", ZStackRenderer);
        self.register_renderer("Text", TextRenderer);
        self.register_renderer("Button", ButtonRenderer);
        self.register_renderer("Image", ImageRenderer);
        self.register_renderer("Scroll", ScrollRenderer);
        self.register_renderer("Spacer", SpacerRenderer);
        self.register_renderer("Divider", DividerRenderer);
    }
}

use std::sync::OnceLock;

static TRANSFORMER_REGISTRY: OnceLock<RwLock<ComponentTransformerRegistry>> = OnceLock::new();

pub fn transformer_registry() -> &'static RwLock<ComponentTransformerRegistry> {
    TRANSFORMER_REGISTRY.get_or_init(|| {
        let mut registry = ComponentTransformerRegistry::new();
        registry.register_standard_transformers();
        RwLock::new(registry)
    })
}

pub fn transform_component(component: &UIComponent) -> RenderNode {
    let registry = transformer_registry().read().unwrap();
    
    if let Some(node) = registry.transform(component) {
        return node;
    }
    
    match component {
        UIComponent::Text(props) => crate::render::transformers::transform_text(props),
        UIComponent::Button(props) => crate::render::transformers::transform_button(props),
        UIComponent::VStack(props) => crate::render::transformers::transform_vstack(props),
        UIComponent::HStack(props) => crate::render::transformers::transform_hstack(props),
        UIComponent::ZStack(props) => crate::render::transformers::transform_zstack(props),
        UIComponent::Image(props) => crate::render::transformers::transform_image(props),
        UIComponent::Scroll(props) => crate::render::transformers::transform_scroll(props),
        UIComponent::Spacer(props) => crate::render::transformers::transform_spacer(props),
        UIComponent::Divider(props) => crate::render::transformers::transform_divider(props),
    }
}

pub fn renderer_registry<T: DrawingContext + 'static>() -> &'static RwLock<ComponentRendererRegistry<T>> {
    static REGISTRIES: OnceLock<RwLock<HashMap<TypeId, Box<dyn Any + Send + Sync>>>> = OnceLock::new();
    
    use std::any::{Any, TypeId};
    
    let type_id = TypeId::of::<T>();
    let registries = REGISTRIES.get_or_init(|| RwLock::new(HashMap::new()));
    
    let mut registries_lock = registries.write().unwrap();
    
    if !registries_lock.contains_key(&type_id) {
        let mut registry = ComponentRendererRegistry::<T>::new();
        registry.register_standard_renderers();
        let registry = RwLock::new(registry);
        
        registries_lock.insert(type_id, Box::new(registry) as Box<dyn Any + Send + Sync>);
    }
    
    let registry_any = registries_lock.get(&type_id).unwrap();
    let registry_box = registry_any.downcast_ref::<RwLock<ComponentRendererRegistry<T>>>().unwrap();
    
    unsafe {
        std::mem::transmute(registry_box)
    }
```

## File: edge_insets.rs

```rs
use serde::{Serialize, Deserialize};
use std::fmt;

/// EdgeInsets represents padding or margins with different values for each side.
/// This structure provides a canonical representation for edge insets throughout the framework.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct EdgeInsets {
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
    pub left: f32,
}

impl EdgeInsets {
    /// Creates a new EdgeInsets with specific values for each side
    pub fn new(top: f32, right: f32, bottom: f32, left: f32) -> Self {
        Self { top, right, bottom, left }
    }
    
    /// Creates EdgeInsets with the same value for all sides
    pub fn all(value: f32) -> Self {
        Self::new(value, value, value, value)
    }
    
    /// Creates EdgeInsets with horizontal (left, right) values
    pub fn horizontal(value: f32) -> Self {
        Self::new(0.0, value, 0.0, value)
    }
    
    /// Creates EdgeInsets with vertical (top, bottom) values
    pub fn vertical(value: f32) -> Self {
        Self::new(value, 0.0, value, 0.0)
    }
    
    /// Creates EdgeInsets with different values for vertical and horizontal
    pub fn symmetric(vertical: f32, horizontal: f32) -> Self {
        Self::new(vertical, horizontal, vertical, horizontal)
    }
    
    /// Creates EdgeInsets with zero for all sides
    pub fn zero() -> Self {
        Self::all(0.0)
    }
    
    /// Converts EdgeInsets to a string representation
    pub fn to_string(&self) -> String {
        format!("{},{},{},{}", self.top, self.right, self.bottom, self.left)
    }
    
    /// Returns the sum of horizontal insets (left + right)
    pub fn horizontal_insets(&self) -> f32 {
        self.left + self.right
    }
    
    /// Returns the sum of vertical insets (top + bottom)
    pub fn vertical_insets(&self) -> f32 {
        self.top + self.bottom
    }
    
    /// Scales all insets by a factor
    pub fn scale(&self, factor: f32) -> Self {
        Self::new(
            self.top * factor,
            self.right * factor,
            self.bottom * factor,
            self.left * factor
        )
    }
    
    /// Adds another EdgeInsets to this one
    pub fn add(&self, other: &EdgeInsets) -> Self {
        Self::new(
            self.top + other.top,
            self.right + other.right,
            self.bottom + other.bottom,
            self.left + other.left
        )
    }
    
    /// Returns an EdgeInsets with the maximum values from this and another
    pub fn max(&self, other: &EdgeInsets) -> Self {
        Self::new(
            self.top.max(other.top),
            self.right.max(other.right),
            self.bottom.max(other.bottom),
            self.left.max(other.left)
        )
    }
    
    /// Returns an EdgeInsets with the minimum values from this and another
    pub fn min(&self, other: &EdgeInsets) -> Self {
        Self::new(
            self.top.min(other.top),
            self.right.min(other.right),
            self.bottom.min(other.bottom),
            self.left.min(other.left)
        )
    }
}

impl Default for EdgeInsets {
    fn default() -> Self {
        Self::zero()
    }
}

impl fmt::Display for EdgeInsets {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{},{},{},{}", self.top, self.right, self.bottom, self.left)
    }
}

/// Parse a string into EdgeInsets
/// 
/// Handles formats like:
/// - "10,20,30,40" (top, right, bottom, left)
/// - "10" (all sides)
/// - "10,20" (vertical, horizontal)
pub fn parse_edge_insets(insets_str: &str) -> Option<EdgeInsets> {
    let parts: Vec<&str> = insets_str.split(',').collect();
    
    match parts.len() {
        // Format: "value" - all sides equal
        1 => {
            let value = parts[0].trim().parse::<f32>().ok()?;
            Some(EdgeInsets::all(value))
        },
        
        // Format: "vertical,horizontal"
        2 => {
            let vertical = parts[0].trim().parse::<f32>().ok()?;
            let horizontal = parts[1].trim().parse::<f32>().ok()?;
            Some(EdgeInsets::symmetric(vertical, horizontal))
        },
        
        // Format: "top,right,bottom,left"
        4 => {
            let top = parts[0].trim().parse::<f32>().ok()?;
            let right = parts[1].trim().parse::<f32>().ok()?;
            let bottom = parts[2].trim().parse::<f32>().ok()?;
            let left = parts[3].trim().parse::<f32>().ok()?;
            Some(EdgeInsets::new(top, right, bottom, left))
        },
        
        // Invalid format
        _ => None,
    }
}

/// Formats EdgeInsets as a canonical string representation
pub fn format_edge_insets(insets: &EdgeInsets) -> String {
    format!("{},{},{},{}", insets.top, insets.right, insets.bottom, insets.left)
}

/// Normalizes EdgeInsets to ensure all values are non-negative
pub fn normalize_edge_insets(insets: &EdgeInsets) -> EdgeInsets {
    EdgeInsets::new(
        insets.top.max(0.0),
        insets.right.max(0.0),
        insets.bottom.max(0.0),
        insets.left.max(0.0)
    )
}

/// Utility functions for edge insets calculations
pub mod utils {
    use super::*;
    use crate::layout::types::Size;
    use crate::layout::types::Rect;
    
    /// Apply edge insets to a size by reducing it
    pub fn apply_insets_to_size(size: &Size, insets: &EdgeInsets) -> Size {
        Size::new(
            (size.width - insets.horizontal_insets()).max(0.0),
            (size.height - insets.vertical_insets()).max(0.0)
        )
    }
    
    /// Apply edge insets to a rect, creating an inner rect
    pub fn apply_insets_to_rect(rect: &Rect, insets: &EdgeInsets) -> Rect {
        Rect::new(
            rect.x + insets.left,
            rect.y + insets.top,
            (rect.width - insets.horizontal_insets()).max(0.0),
            (rect.height - insets.vertical_insets()).max(0.0)
        )
    }
    
    /// Creates a rect expanded by the edge insets
    pub fn expand_rect_by_insets(rect: &Rect, insets: &EdgeInsets) -> Rect {
        Rect::new(
            rect.x - insets.left,
            rect.y - insets.top,
            rect.width + insets.horizontal_insets(),
            rect.height + insets.vertical_insets()
        )
    }
```

## File: layout_info.rs

```rs
use std::collections::HashMap;
use super::types::{Alignment, Rect, Size};

#[derive(Debug, Clone)]
pub struct LayoutInfo {
    pub frame: Rect,
    pub padding: Option<f32>,
    pub alignment: Option<Alignment>,
    pub content_size: Size,
    pub flex_grow: Option<f32>,
    pub flex_shrink: Option<f32>,
    pub flex_basis: Option<f32>,
    pub min_width: Option<f32>,
    pub max_width: Option<f32>,
    pub min_height: Option<f32>,
    pub max_height: Option<f32>,
    pub parent_type: Option<String>,
    pub resolved_props: HashMap<String, String>,
}

impl LayoutInfo {
    pub fn new() -> Self {
        Self {
            frame: Rect::zero(),
            padding: None,
            alignment: None,
            content_size: Size::zero(),
            flex_grow: None,
            flex_shrink: None,
            flex_basis: None,
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None,
            parent_type: None,
            resolved_props: HashMap::new(),
        }
    }
    
    pub fn with_frame(mut self, frame: Rect) -> Self {
        self.frame = frame;
        self
    }
    
    pub fn with_padding(mut self, padding: f32) -> Self {
        self.padding = Some(padding);
        self
    }
    
    pub fn with_alignment(mut self, alignment: Alignment) -> Self {
        self.alignment = Some(alignment);
        self
    }
    
    pub fn with_content_size(mut self, size: Size) -> Self {
        self.content_size = size;
        self
    }
    
    pub fn with_flex_grow(mut self, flex_grow: f32) -> Self {
        self.flex_grow = Some(flex_grow);
        self
    }
    
    pub fn with_flex_shrink(mut self, flex_shrink: f32) -> Self {
        self.flex_shrink = Some(flex_shrink);
        self
    }
    
    pub fn with_flex_basis(mut self, flex_basis: f32) -> Self {
        self.flex_basis = Some(flex_basis);
        self
    }
    
    pub fn with_min_width(mut self, min_width: f32) -> Self {
        self.min_width = Some(min_width);
        self
    }
    
    pub fn with_max_width(mut self, max_width: f32) -> Self {
        self.max_width = Some(max_width);
        self
    }
    
    pub fn with_min_height(mut self, min_height: f32) -> Self {
        self.min_height = Some(min_height);
        self
    }
    
    pub fn with_max_height(mut self, max_height: f32) -> Self {
        self.max_height = Some(max_height);
        self
    }
    
    pub fn with_parent_type(mut self, parent_type: &str) -> Self {
        self.parent_type = Some(parent_type.to_string());
        self
    }
    
    pub fn inner_rect(&self) -> Rect {
        if let Some(padding) = self.padding {
            self.frame.inset(padding)
        } else {
            self.frame
        }
    }
    
    pub fn constrain_size(&self, size: Size) -> Size {
        let width = if let Some(max_width) = self.max_width {
            size.width.min(max_width)
        } else {
            size.width
        };
        
        let width = if let Some(min_width) = self.min_width {
            width.max(min_width)
        } else {
            width
        };
        
        let height = if let Some(max_height) = self.max_height {
            size.height.min(max_height)
        } else {
            size.height
        };
        
        let height = if let Some(min_height) = self.min_height {
            height.max(min_height)
        } else {
            height
        };
        
        Size::new(width, height)
    }
```

## File: event_handler.rs

```rs
use std::sync::{Arc, Mutex};
use std::collections::{HashMap, HashSet};

use super::event_system::{Event, EventType};
use super::event_types::EventSource;

pub trait EventHandlerFn: Send + Sync {
    fn call(&self, event: &mut Event) -> HandlerResult;
}

#[derive(Debug, PartialEq)]
pub enum HandlerResult {
    Handled,
    Partial,
    Unhandled,
}

impl<F> EventHandlerFn for F 
where 
    F: Fn(&mut Event) -> HandlerResult + Send + Sync + 'static 
{
    fn call(&self, event: &mut Event) -> HandlerResult {
        (self)(event)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum HandlerPriority {
    Low = 0,
    Normal = 10,
    High = 20,
    Critical = 30,
}

pub struct TypedEventHandler {
    pub id: String,
    
    pub handler: Arc<dyn EventHandlerFn>,
    
    pub filter: Option<Arc<dyn Fn(&Event) -> bool + Send + Sync>>,
    
    pub priority: HandlerPriority,
    
    pub allowed_sources: Option<Vec<EventSource>>,
    
    pub max_calls: Option<usize>,
    
    pub current_calls: usize,
}

impl TypedEventHandler {
    pub fn new<F>(
        id: &str, 
        handler: F
    ) -> Self 
    where 
        F: Fn(&mut Event) -> HandlerResult + Send + Sync + 'static 
    {
        Self {
            id: id.to_string(),
            handler: Arc::new(handler),
            filter: None,
            priority: HandlerPriority::Normal,
            allowed_sources: None,
            max_calls: None,
            current_calls: 0,
        }
    }
    
    pub fn with_filter<F>(mut self, filter: F) -> Self 
    where 
        F: Fn(&Event) -> bool + Send + Sync + 'static 
    {
        self.filter = Some(Arc::new(filter));
        self
    }
    
    pub fn with_priority(mut self, priority: HandlerPriority) -> Self {
        self.priority = priority;
        self
    }
    
    pub fn with_sources(mut self, sources: &[EventSource]) -> Self {
        self.allowed_sources = Some(sources.to_vec());
        self
    }
    
    pub fn with_max_calls(mut self, max_calls: usize) -> Self {
        self.max_calls = Some(max_calls);
        self
    }
    
    pub fn handle(&mut self, event: &mut Event) -> HandlerResult {
        if let Some(max_calls) = self.max_calls {
            if self.current_calls >= max_calls {
                return HandlerResult::Unhandled;
            }
        }
        
        if let Some(sources) = &self.allowed_sources {
            if !sources.iter().any(|source| *source == event.metadata.source) {
                return HandlerResult::Unhandled;
            }
        }
        
        if let Some(filter) = &self.filter {
            if !(filter)(event) {
                return HandlerResult::Unhandled;
            }
        }
        
        let result = self.handler.call(event);
        
        if result != HandlerResult::Unhandled {
            self.current_calls += 1;
        }
        
        result
    }
}

pub struct EventDispatcher {
    handlers: Mutex<HashMap<EventType, Vec<TypedEventHandler>>>,
    
    global_handlers: Mutex<Vec<TypedEventHandler>>,
}

impl EventDispatcher {
    pub fn new() -> Self {
        Self {
            handlers: Mutex::new(HashMap::new()),
            global_handlers: Mutex::new(Vec::new()),
        }
    }
    
    pub fn register_handler(
        &self, 
        event_type: EventType, 
        handler: TypedEventHandler
    ) {
        let mut handlers = self.handlers.lock().unwrap();
        handlers
            .entry(event_type.clone())
            .or_insert_with(Vec::new)
            .push(handler);
        
        handlers.get_mut(&event_type).unwrap()
            .sort_by(|a, b| b.priority.cmp(&a.priority));
    }
    
    pub fn register_global_handler(&self, handler: TypedEventHandler) {
        let mut global_handlers = self.global_handlers.lock().unwrap();
        global_handlers.push(handler);
        
        global_handlers.sort_by(|a, b| b.priority.cmp(&a.priority));
    }
    
    pub fn dispatch(&self, event: &mut Event) -> HandlerResult {
        let mut overall_result = HandlerResult::Unhandled;
        
        {
            let mut global_handlers = self.global_handlers.lock().unwrap();
            for handler in global_handlers.iter_mut() {
                let result = handler.handle(event);
                
                match result {
                    HandlerResult::Handled => {
                        overall_result = HandlerResult::Handled;
                        break;
                    },
                    HandlerResult::Partial => {
                        overall_result = HandlerResult::Partial;
                    },
                    HandlerResult::Unhandled => {}
                }
                
                if event.is_stopped {
                    break;
                }
            }
        }
        
        if overall_result != HandlerResult::Handled && !event.is_stopped {
            let mut handlers = self.handlers.lock().unwrap();
            
            if let Some(type_handlers) = handlers.get_mut(&event.event_type) {
                for handler in type_handlers {
                    let result = handler.handle(event);
                    
                    match result {
                        HandlerResult::Handled => {
                            overall_result = HandlerResult::Handled;
                            break;
                        },
                        HandlerResult::Partial => {
                            overall_result = HandlerResult::Partial;
                        },
                        HandlerResult::Unhandled => {}
                    }
                    
                    if event.is_stopped {
                        break;
                    }
                }
            }
        }
        
        overall_result
    }
    
    pub fn clear_handlers(&self, event_type: &EventType) {
        let mut handlers = self.handlers.lock().unwrap();
        handlers.remove(event_type);
    }
    
    pub fn remove_handler(&self, event_type: &EventType, handler_id: &str) {
        let mut handlers = self.handlers.lock().unwrap();
        
        if let Some(type_handlers) = handlers.get_mut(event_type) {
            type_handlers.retain(|handler| handler.id != handler_id);
        }
    }
}

pub struct ButtonEventHandler {
    pub on_tap: Option<String>,
    pub on_double_tap: Option<String>,
    pub on_long_press: Option<String>,
    pub on_hover_enter: Option<String>,
    pub on_hover_exit: Option<String>,
    pub on_focus: Option<String>,
    pub on_blur: Option<String>,
}

impl ButtonEventHandler {
    pub fn new() -> Self {
        Self {
            on_tap: None,
            on_double_tap: None,
            on_long_press: None,
            on_hover_enter: None,
            on_hover_exit: None,
            on_focus: None,
            on_blur: None,
        }
    }
    
    pub fn with_tap_handler(mut self, handler_id: &str) -> Self {
        self.on_tap = Some(handler_id.to_string());
        self
    }
    
    pub fn with_double_tap_handler(mut self, handler_id: &str) -> Self {
        self.on_double_tap = Some(handler_id.to_string());
        self
    }
    
    pub fn with_long_press_handler(mut self, handler_id: &str) -> Self {
        self.on_long_press = Some(handler_id.to_string());
        self
    }
    
    pub fn with_hover_enter_handler(mut self, handler_id: &str) -> Self {
        self.on_hover_enter = Some(handler_id.to_string());
        self
    }
    
    pub fn with_hover_exit_handler(mut self, handler_id: &str) -> Self {
        self.on_hover_exit = Some(handler_id.to_string());
        self
    }
    
    pub fn with_focus_handler(mut self, handler_id: &str) -> Self {
        self.on_focus = Some(handler_id.to_string());
        self
    }
    
    pub fn with_blur_handler(mut self, handler_id: &str) -> Self {
        self.on_blur = Some(handler_id.to_string());
        self
    }
    
    pub fn get_handler_id(&self, event_type: &EventType) -> Option<&String> {
        match event_type {
            EventType::Tap => self.on_tap.as_ref(),
            EventType::DoubleTap => self.on_double_tap.as_ref(),
            EventType::LongPress => self.on_long_press.as_ref(),
            EventType::HoverEnter => self.on_hover_enter.as_ref(),
            EventType::HoverExit => self.on_hover_exit.as_ref(),
            EventType::Focus => self.on_focus.as_ref(),
            EventType::Blur => self.on_blur.as_ref(),
            _ => None,
        }
    }
```

## File: color.rs

```rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "PascalCase")]
pub enum Color {
    White,
    Black,
    
    Red,
    Green,
    Blue,
    Yellow,
    
    Orange,
    Purple,
    Pink,
    Teal,
    Indigo,
    Cyan,
    
    Gray,
    LightGray,
    DarkGray,
    
    Primary,
    Secondary,
    Accent,
    Background,
    Surface,
    Error,
    OnPrimary,
    OnSecondary,
    OnBackground,
    OnSurface,
    OnError,
    
    Success,
    Warning,
    Info,
    Danger,
    
    Twitter,
    Facebook,
    LinkedIn,
    Instagram,
    
    Link,
    Disabled,
    Placeholder,
    
    Transparent,
    Custom(u8, u8, u8),
    CustomWithAlpha(u8, u8, u8, f32),
    Hex(String),
}

impl Color {
    pub fn to_css_string(&self) -> String {
        match self {
            Color::White => "#FFFFFF".to_string(),
            Color::Black => "#000000".to_string(),
            
            Color::Red => "#FF0000".to_string(),
            Color::Green => "#00FF00".to_string(),
            Color::Blue => "#0000FF".to_string(),
            Color::Yellow => "#FFFF00".to_string(),
            
            Color::Orange => "#FFA500".to_string(),
            Color::Purple => "#800080".to_string(),
            Color::Pink => "#FFC0CB".to_string(),
            Color::Teal => "#008080".to_string(),
            Color::Indigo => "#4B0082".to_string(),
            Color::Cyan => "#00FFFF".to_string(),
            
            Color::Gray => "#808080".to_string(),
            Color::LightGray => "#D3D3D3".to_string(),
            Color::DarkGray => "#A9A9A9".to_string(),
            
            Color::Primary => "#6200EE".to_string(),
            Color::Secondary => "#03DAC6".to_string(),
            Color::Accent => "#03DAC6".to_string(),
            Color::Background => "#FFFFFF".to_string(),
            Color::Surface => "#FFFFFF".to_string(),
            Color::Error => "#B00020".to_string(),
            Color::OnPrimary => "#FFFFFF".to_string(),
            Color::OnSecondary => "#000000".to_string(),
            Color::OnBackground => "#000000".to_string(),
            Color::OnSurface => "#000000".to_string(),
            Color::OnError => "#FFFFFF".to_string(),
            
            Color::Success => "#4CAF50".to_string(),
            Color::Warning => "#FF9800".to_string(),
            Color::Info => "#2196F3".to_string(),
            Color::Danger => "#F44336".to_string(),
            
            Color::Twitter => "#1DA1F2".to_string(),
            Color::Facebook => "#1877F2".to_string(),
            Color::LinkedIn => "#0A66C2".to_string(),
            Color::Instagram => "#E4405F".to_string(),
            
            Color::Link => "#0000EE".to_string(),
            Color::Disabled => "#9E9E9E".to_string(),
            Color::Placeholder => "#9E9E9E".to_string(),
            
            Color::Transparent => "transparent".to_string(),
            Color::Custom(r, g, b) => format!("rgb({}, {}, {})", r, g, b),
            Color::CustomWithAlpha(r, g, b, a) => format!("rgba({}, {}, {}, {})", r, g, b, a),
            Color::Hex(hex) => {
                if hex.starts_with('#') {
                    hex.clone()
                } else {
                    format!("#{}", hex)
                }
            },
        }
    }
    
    pub fn rgb(r: u8, g: u8, b: u8) -> Self {
        Color::Custom(r, g, b)
    }
    
    pub fn rgba(r: u8, g: u8, b: u8, a: f32) -> Self {
        Color::CustomWithAlpha(r, g, b, a.max(0.0).min(1.0))
    }
    
    pub fn from_hex(hex: &str) -> Self {
        Color::Hex(hex.to_string())
    }
    
    pub fn is_dark(&self) -> bool {
        match self {
            Color::White | 
            Color::Yellow | 
            Color::LightGray | 
            Color::Background |
            Color::Surface | 
            Color::Secondary | 
            Color::Accent |
            Color::Warning => false,
            
            Color::Custom(r, g, b) => {
                let brightness = 0.299 * (*r as f32) + 0.587 * (*g as f32) + 0.114 * (*b as f32);
                brightness < 128.0
            },
            
            Color::CustomWithAlpha(r, g, b, _) => {
                let brightness = 0.299 * (*r as f32) + 0.587 * (*g as f32) + 0.114 * (*b as f32);
                brightness < 128.0
            },
            
            Color::Hex(hex) => {
                if hex.len() >= 7 {
                    let r = u8::from_str_radix(&hex[1..3], 16).unwrap_or(0);
                    let g = u8::from_str_radix(&hex[3..5], 16).unwrap_or(0);
                    let b = u8::from_str_radix(&hex[5..7], 16).unwrap_or(0);
                    
                    let brightness = 0.299 * (r as f32) + 0.587 * (g as f32) + 0.114 * (b as f32);
                    brightness < 128.0
                } else {
                    true
                }
            },
            
            _ => true,
        }
    }
    
    pub fn contrasting_text_color(&self) -> Self {
        if self.is_dark() {
            Color::White
        } else {
            Color::Black
        }
    }
    
    pub fn lighten(&self, amount: f32) -> Self {
        match self {
            Color::Custom(r, g, b) => {
                let amount = amount.max(0.0).min(1.0);
                let r = (*r as f32 + (255.0 - *r as f32) * amount) as u8;
                let g = (*g as f32 + (255.0 - *g as f32) * amount) as u8;
                let b = (*b as f32 + (255.0 - *b as f32) * amount) as u8;
                Color::Custom(r, g, b)
            },
            _ => self.clone(),
        }
    }
    
    pub fn darken(&self, amount: f32) -> Self {
        match self {
            Color::Custom(r, g, b) => {
                let amount = amount.max(0.0).min(1.0);
                let r = (*r as f32 * (1.0 - amount)) as u8;
                let g = (*g as f32 * (1.0 - amount)) as u8;
                let b = (*b as f32 * (1.0 - amount)) as u8;
                Color::Custom(r, g, b)
            },
            _ => self.clone(),
        }
    }
    
    pub fn with_opacity(&self, opacity: f32) -> Self {
        let opacity = opacity.max(0.0).min(1.0);
        match self {
            Color::Custom(r, g, b) => Color::CustomWithAlpha(*r, *g, *b, opacity),
            Color::CustomWithAlpha(r, g, b, _) => Color::CustomWithAlpha(*r, *g, *b, opacity),
            _ => self.clone(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ThemeMode {
    Light,
    Dark,
    System,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ColorScheme {
    pub primary: Color,
    pub secondary: Color,
    pub background: Color,
    pub surface: Color,
    pub error: Color,
    pub on_primary: Color,
    pub on_secondary: Color,
    pub on_background: Color,
    pub on_surface: Color,
    pub on_error: Color,
}

impl Default for ColorScheme {
    fn default() -> Self {
        Self {
            primary: Color::Primary,
            secondary: Color::Secondary,
            background: Color::Background,
            surface: Color::Surface,
            error: Color::Error,
            on_primary: Color::OnPrimary,
            on_secondary: Color::OnSecondary,
            on_background: Color::OnBackground,
            on_surface: Color::OnSurface,
            on_error: Color::OnError,
        }
    }
}

pub mod color_schemes {
    use super::{ColorScheme, Color};
    
    pub fn light() -> ColorScheme {
        ColorScheme::default()
    }
    
    pub fn dark() -> ColorScheme {
        ColorScheme {
            primary: Color::Primary,
            secondary: Color::Secondary,
            background: Color::Black,
            surface: Color::DarkGray,
            error: Color::Error,
            on_primary: Color::White,
            on_secondary: Color::Black,
            on_background: Color::White,
            on_surface: Color::White,
            on_error: Color::White,
        }
    }
    
    pub fn blue_light() -> ColorScheme {
        ColorScheme {
            primary: Color::Blue,
            secondary: Color::Cyan,
            background: Color::White,
            surface: Color::White,
            error: Color::Red,
            on_primary: Color::White,
            on_secondary: Color::Black,
            on_background: Color::Black,
            on_surface: Color::Black,
            on_error: Color::White,
        }
    }
    
    pub fn red_light() -> ColorScheme {
        ColorScheme {
            primary: Color::Red,
            secondary: Color::Pink,
            background: Color::White,
            surface: Color::White,
            error: Color::Error,
            on_primary: Color::White,
            on_secondary: Color::White,
            on_background: Color::Black,
            on_surface: Color::Black,
            on_error: Color::White,
        }
    }
    
    pub fn green_light() -> ColorScheme {
        ColorScheme {
            primary: Color::Green,
            secondary: Color::Teal,
            background: Color::White,
            surface: Color::White,
            error: Color::Red,
            on_primary: Color::Black,
            on_secondary: Color::White,
            on_background: Color::Black,
            on_surface: Color::Black,
            on_error: Color::White,
        }
    }
```

## File: properties.rs

```rs
use std::collections::HashMap;
use std::fmt;
use serde::{Serialize, Deserialize};
use crate::{shared::color::Color, EdgeInsets};
// use crate::layout::types::EdgeInsets;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum Property {
    String(String),
    Number(f32),
    Boolean(bool),
    Color(Color),
    EdgeInsets(EdgeInsets),
    None,
}

impl Property {
    pub fn as_string(&self) -> Option<&String> {
        match self {
            Property::String(value) => Some(value),
            _ => None,
        }
    }

    pub fn as_number(&self) -> Option<f32> {
        match self {
            Property::Number(value) => Some(*value),
            _ => None,
        }
    }

    pub fn as_boolean(&self) -> Option<bool> {
        match self {
            Property::Boolean(value) => Some(*value),
            _ => None,
        }
    }

    pub fn as_color(&self) -> Option<&Color> {
        match self {
            Property::Color(value) => Some(value),
            _ => None,
        }
    }

    pub fn as_edge_insets(&self) -> Option<&EdgeInsets> {
        match self {
            Property::EdgeInsets(value) => Some(value),
            _ => None,
        }
    }
    
    pub fn to_string_value(&self) -> String {
        match self {
            Property::String(value) => value.clone(),
            Property::Number(value) => value.to_string(),
            Property::Boolean(value) => value.to_string(),
            Property::Color(value) => value.to_css_string(),
            Property::EdgeInsets(value) => format!("{},{},{},{}", 
                value.top, value.right, value.bottom, value.left),
            Property::None => "none".to_string(),
        }
    }
}

impl fmt::Display for Property {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Property::String(value) => write!(f, "{}", value),
            Property::Number(value) => write!(f, "{}", value),
            Property::Boolean(value) => write!(f, "{}", value),
            Property::Color(value) => write!(f, "{:?}", value),
            Property::EdgeInsets(value) => write!(f, "{},{},{},{}", 
                value.top, value.right, value.bottom, value.left),
            Property::None => write!(f, "None"),
        }
    }
}

impl From<String> for Property {
    fn from(value: String) -> Self {
        Property::String(value)
    }
}

impl From<&str> for Property {
    fn from(value: &str) -> Self {
        Property::String(value.to_string())
    }
}

impl From<f32> for Property {
    fn from(value: f32) -> Self {
        Property::Number(value)
    }
}

impl From<i32> for Property {
    fn from(value: i32) -> Self {
        Property::Number(value as f32)
    }
}

impl From<bool> for Property {
    fn from(value: bool) -> Self {
        Property::Boolean(value)
    }
}

impl From<Color> for Property {
    fn from(value: Color) -> Self {
        Property::Color(value)
    }
}

impl From<EdgeInsets> for Property {
    fn from(value: EdgeInsets) -> Self {
        Property::EdgeInsets(value)
    }
}

#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]
pub struct PropertyBag {
    properties: HashMap<String, Property>,
}

impl PropertyBag {
    pub fn new() -> Self {
        Self {
            properties: HashMap::new(),
        }
    }

    pub fn set<T: Into<Property>>(&mut self, key: &str, value: T) {
        self.properties.insert(key.to_string(), value.into());
    }

    pub fn get(&self, key: &str) -> Option<&Property> {
        self.properties.get(key)
    }

    pub fn get_string(&self, key: &str) -> Option<&String> {
        self.get(key).and_then(|prop| prop.as_string())
    }

    pub fn get_number(&self, key: &str) -> Option<f32> {
        self.get(key).and_then(|prop| prop.as_number())
    }

    pub fn get_boolean(&self, key: &str) -> Option<bool> {
        self.get(key).and_then(|prop| prop.as_boolean())
    }

    pub fn get_color(&self, key: &str) -> Option<&Color> {
        self.get(key).and_then(|prop| prop.as_color())
    }

    pub fn get_edge_insets(&self, key: &str) -> Option<&EdgeInsets> {
        self.get(key).and_then(|prop| prop.as_edge_insets())
    }

    pub fn has(&self, key: &str) -> bool {
        self.properties.contains_key(key)
    }

    pub fn remove(&mut self, key: &str) -> Option<Property> {
        self.properties.remove(key)
    }

    pub fn keys(&self) -> impl Iterator<Item = &String> {
        self.properties.keys()
    }

    pub fn values(&self) -> impl Iterator<Item = &Property> {
        self.properties.values()
    }

    pub fn entries(&self) -> impl Iterator<Item = (&String, &Property)> {
        self.properties.iter()
    }

    pub fn len(&self) -> usize {
        self.properties.len()
    }

    pub fn is_empty(&self) -> bool {
        self.properties.is_empty()
    }
    
    pub fn get_as_string(&self, key: &str) -> Option<String> {
        self.get(key).map(|prop| prop.to_string_value())
    }
    
    pub fn from_string_map(map: &HashMap<String, String>) -> Self {
        let mut bag = Self::new();
        for (key, value) in map {
            if let Ok(num) = value.parse::<f32>() {
                bag.set(key, Property::Number(num));
            } else if let Ok(bool_val) = value.parse::<bool>() {
                bag.set(key, Property::Boolean(bool_val));
            } else if let Some(edge_insets) = parse_edge_insets(value) {
                bag.set(key, Property::EdgeInsets(edge_insets));
            } else if let Some(color) = parse_color(value) {
                bag.set(key, Property::Color(color));
            } else {
                bag.set(key, Property::String(value.clone()));
            }
        }
        bag
    }
    
    pub fn to_string_map(&self) -> HashMap<String, String> {
        let mut map = HashMap::new();
        for (key, value) in &self.properties {
            map.insert(key.clone(), value.to_string_value());
        }
        map
    }
}

pub fn parse_edge_insets(value: &str) -> Option<EdgeInsets> {
    let parts: Vec<&str> = value.split(',').collect();
    if parts.len() == 4 {
        let top = parts[0].trim().parse::<f32>().ok()?;
        let right = parts[1].trim().parse::<f32>().ok()?;
        let bottom = parts[2].trim().parse::<f32>().ok()?;
        let left = parts[3].trim().parse::<f32>().ok()?;
        Some(EdgeInsets::new(top, right, bottom, left))
    } else {
        None
    }
}

pub fn parse_color(value: &str) -> Option<Color> {
    match value.trim().to_lowercase().as_str() {
        "white" => Some(Color::White),
        "black" => Some(Color::Black),
        "red" => Some(Color::Red),
        "green" => Some(Color::Green),
        "blue" => Some(Color::Blue),
        "yellow" => Some(Color::Yellow),
        "orange" => Some(Color::Orange),
        "purple" => Some(Color::Purple),
        "pink" => Some(Color::Pink),
        "teal" => Some(Color::Teal),
        "gray" | "grey" => Some(Color::Gray),
        "lightgray" | "lightgrey" => Some(Color::LightGray),
        "darkgray" | "darkgrey" => Some(Color::DarkGray),
        "transparent" => Some(Color::Transparent),
        _ => {
            if value.starts_with('#') {
                Some(Color::Hex(value.to_string()))
            } else if value.starts_with("rgb(") || value.starts_with("rgba(") {
                let inner = value.trim_start_matches("rgb(").trim_start_matches("rgba(").trim_end_matches(')');
                let parts: Vec<&str> = inner.split(',').collect();
                
                if parts.len() >= 3 {
                    if let (Ok(r), Ok(g), Ok(b)) = (
                        parts[0].trim().parse::<u8>(),
                        parts[1].trim().parse::<u8>(),
                        parts[2].trim().parse::<u8>(),
                    ) {
                        if parts.len() >= 4 {
                            if let Ok(a) = parts[3].trim().parse::<f32>() {
                                return Some(Color::CustomWithAlpha(r, g, b, a));
                            }
                        }
                        return Some(Color::Custom(r, g, b));
                    }
                }
                None
            } else {
                None
            }
        }
    }
}

pub mod utils {
    use super::*;
    
    pub fn set_optional_prop<T: Into<Property> + Clone>(bag: &mut PropertyBag, key: &str, value: &Option<T>) {
        if let Some(val) = value {
            bag.set(key, val.clone());
        }
    }
    
    pub fn get_prop_with_default<T, F>(bag: &PropertyBag, key: &str, converter: F, default: T) -> T 
    where 
        F: FnOnce(&Property) -> Option<T> 
    {
        bag.get(key).and_then(converter).unwrap_or(default)
    }
}

```

## File: property.rs

```rs
// src/render/property.rs
use std::collections::HashMap;
use std::fmt;
use serde::{Serialize, Deserialize};
use crate::shared::color::Color;
use crate::shared::edge_insets::EdgeInsets;
use crate::styles::{Gradient, ShadowEffect, BorderStyle, TextAlign, TextTransform, Overflow};
use crate::font::{FontWeight, FontSlant, FontWidth, FontFeatures};

/// Property key definitions to ensure consistent naming throughout the system
pub mod keys {
    pub const THICKNESS: &str = "thickness";
    // Visual properties
    pub const BACKGROUND: &str = "background";
    pub const OPACITY: &str = "opacity";
    
    // Layout properties
    pub const WIDTH: &str = "width";
    pub const HEIGHT: &str = "height";
    pub const MIN_WIDTH: &str = "min_width";
    pub const MAX_WIDTH: &str = "max_width";
    pub const MIN_HEIGHT: &str = "min_height";
    pub const MAX_HEIGHT: &str = "max_height";
    pub const PADDING: &str = "padding";
    pub const EDGE_INSETS: &str = "edge_insets";
    pub const ALIGNMENT: &str = "alignment";
    pub const SPACING: &str = "spacing";
    pub const EQUAL_SPACING: &str = "equal_spacing";
    pub const FLEX_GROW: &str = "flex_grow";
    
    // Border properties
    pub const BORDER_WIDTH: &str = "border_width";
    pub const BORDER_COLOR: &str = "border_color";
    pub const BORDER_RADIUS: &str = "border_radius";
    pub const BORDER_STYLE: &str = "border_style";
    
    // Shadow properties
    pub const SHADOW_RADIUS: &str = "shadow_radius";
    pub const SHADOW_COLOR: &str = "shadow_color";
    pub const SHADOW_OFFSET_X: &str = "shadow_offset_x";
    pub const SHADOW_OFFSET_Y: &str = "shadow_offset_y";
    
    // Text properties
    pub const TEXT: &str = "text";
    pub const FONT_SIZE: &str = "font_size";
    pub const FONT_WEIGHT: &str = "font_weight";
    pub const FONT_SLANT: &str = "font_slant";
    pub const FONT_WIDTH: &str = "font_width";
    pub const TEXT_COLOR: &str = "text_color";
    pub const TEXT_ALIGNMENT: &str = "text_alignment";
    pub const LINE_HEIGHT: &str = "line_height";
    pub const LETTER_SPACING: &str = "letter_spacing";
    pub const TEXT_TRANSFORM: &str = "text_transform";
    
    // Image properties
    pub const SOURCE: &str = "source";
    pub const CONTENT_MODE: &str = "content_mode";
    pub const TINT_COLOR: &str = "tint_color";
    
    // Interaction properties
    pub const ENABLED: &str = "enabled";
    pub const FOCUSABLE: &str = "focusable";
    pub const PRESSED: &str = "pressed";
    pub const HOVERED: &str = "hovered";
    pub const FOCUSED: &str = "focused";
    
    // Accessibility properties
    pub const ACCESSIBILITY_LABEL: &str = "accessibility_label";
    pub const ACCESSIBILITY_HINT: &str = "accessibility_hint";
    pub const IS_ACCESSIBILITY_ELEMENT: &str = "is_accessibility_element";
    
    // Button properties
    pub const LABEL: &str = "label";
    pub const BUTTON_STYLE: &str = "button_style";
    pub const IS_LOADING: &str = "is_loading";
    
    // Clipping and masking
    pub const CLIP_TO_BOUNDS: &str = "clip_to_bounds";
    pub const OVERFLOW: &str = "overflow";
    
    // Positioning
    pub const X: &str = "x";
    pub const Y: &str = "y";
    
    // Animation
    pub const ANIMATION_DURATION: &str = "animation_duration";
}

/// Defines the different types of properties that can be stored
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum Property {
    /// String value (text, identifiers, etc.)
    String(String),
    /// Numeric value (sizes, dimensions, etc.)
    Number(f32),
    /// Boolean value (flags, toggles, etc.)
    Boolean(bool),
    /// Integer value
    Integer(i32),
    /// Color value (backgrounds, text colors, borders, etc.)
    Color(Color),
    /// Edge insets value (padding, margins, etc.)
    EdgeInsets(EdgeInsets),
    /// Gradient definition
    Gradient(Gradient),
    /// Shadow effect
    ShadowEffect(ShadowEffect),
    /// Font weight
    FontWeight(FontWeight),
    /// Font slant
    FontSlant(FontSlant),
    /// Font width
    FontWidth(FontWidth),
    /// Font features
    FontFeatures(FontFeatures),
    /// Border style
    BorderStyle(BorderStyle),
    /// Text alignment
    TextAlign(TextAlign),
    /// Text transformation
    TextTransform(TextTransform),
    /// Overflow handling
    Overflow(Overflow),
    /// Array of property values
    Array(Vec<Property>),
    /// Map of property values
    Map(HashMap<String, Property>),
    /// None value (explicitly set to none/null)
    None,
}

impl Property {
    // Type-checking getters
    
    /// Gets the value as a string reference if it's a string property
    pub fn as_string(&self) -> Option<&String> {
        match self {
            Property::String(value) => Some(value),
            _ => None,
        }
    }

    /// Gets the value as an f32 if it's a number property
    pub fn as_number(&self) -> Option<f32> {
        match self {
            Property::Number(value) => Some(*value),
            Property::Integer(value) => Some(*value as f32),
            _ => None,
        }
    }

    /// Gets the value as an i32 if it's an integer property
    pub fn as_integer(&self) -> Option<i32> {
        match self {
            Property::Integer(value) => Some(*value),
            Property::Number(value) => {
                // Only convert if it's a whole number
                if *value == (*value as i32) as f32 {
                    Some(*value as i32)
                } else {
                    None
                }
            },
            _ => None,
        }
    }

    /// Gets the value as a boolean if it's a boolean property
    pub fn as_boolean(&self) -> Option<bool> {
        match self {
            Property::Boolean(value) => Some(*value),
            _ => None,
        }
    }

    /// Gets the value as a Color reference if it's a color property
    pub fn as_color(&self) -> Option<&Color> {
        match self {
            Property::Color(value) => Some(value),
            _ => None,
        }
    }

    /// Gets the value as an EdgeInsets reference if it's an edge insets property
    pub fn as_edge_insets(&self) -> Option<&EdgeInsets> {
        match self {
            Property::EdgeInsets(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a Gradient reference if it's a gradient property
    pub fn as_gradient(&self) -> Option<&Gradient> {
        match self {
            Property::Gradient(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a ShadowEffect reference if it's a shadow effect property
    pub fn as_shadow_effect(&self) -> Option<&ShadowEffect> {
        match self {
            Property::ShadowEffect(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a FontWeight reference if it's a font weight property
    pub fn as_font_weight(&self) -> Option<&FontWeight> {
        match self {
            Property::FontWeight(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a FontSlant reference if it's a font slant property
    pub fn as_font_slant(&self) -> Option<&FontSlant> {
        match self {
            Property::FontSlant(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a FontWidth reference if it's a font width property
    pub fn as_font_width(&self) -> Option<&FontWidth> {
        match self {
            Property::FontWidth(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a FontFeatures reference if it's a font features property
    pub fn as_font_features(&self) -> Option<&FontFeatures> {
        match self {
            Property::FontFeatures(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a BorderStyle reference if it's a border style property
    pub fn as_border_style(&self) -> Option<&BorderStyle> {
        match self {
            Property::BorderStyle(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a TextAlign reference if it's a text align property
    pub fn as_text_align(&self) -> Option<&TextAlign> {
        match self {
            Property::TextAlign(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a TextTransform reference if it's a text transform property
    pub fn as_text_transform(&self) -> Option<&TextTransform> {
        match self {
            Property::TextTransform(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as an Overflow reference if it's an overflow property
    pub fn as_overflow(&self) -> Option<&Overflow> {
        match self {
            Property::Overflow(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a Vec<Property> reference if it's an array property
    pub fn as_array(&self) -> Option<&Vec<Property>> {
        match self {
            Property::Array(value) => Some(value),
            _ => None,
        }
    }
    
    /// Gets the value as a HashMap<String, Property> reference if it's a map property
    pub fn as_map(&self) -> Option<&HashMap<String, Property>> {
        match self {
            Property::Map(value) => Some(value),
            _ => None,
        }
    }
    
    /// Attempts to convert the property to a string regardless of its type
    pub fn to_string_value(&self) -> String {
        match self {
            Property::String(value) => value.clone(),
            Property::Number(value) => value.to_string(),
            Property::Integer(value) => value.to_string(),
            Property::Boolean(value) => value.to_string(),
            Property::Color(value) => value.to_css_string(),
            Property::EdgeInsets(value) => format!("{}", value),
            Property::Gradient(_) => "gradient".to_string(),
            Property::ShadowEffect(_) => "shadow".to_string(),
            Property::FontWeight(value) => format!("{:?}", value),
            Property::FontSlant(value) => format!("{:?}", value),
            Property::FontWidth(value) => format!("{:?}", value),
            Property::FontFeatures(_) => "font-features".to_string(),
            Property::BorderStyle(value) => format!("{:?}", value),
            Property::TextAlign(value) => format!("{:?}", value),
            Property::TextTransform(value) => format!("{:?}", value),
            Property::Overflow(value) => format!("{:?}", value),
            Property::Array(_) => "array".to_string(),
            Property::Map(_) => "map".to_string(),
            Property::None => "none".to_string(),
        }
    }
}

// Auto-implement Display for Property
impl fmt::Display for Property {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_string_value())
    }
}

// From implementations for various types
impl From<String> for Property {
    fn from(value: String) -> Self {
        Property::String(value)
    }
}

impl From<&str> for Property {
    fn from(value: &str) -> Self {
        Property::String(value.to_string())
    }
}

impl From<f32> for Property {
    fn from(value: f32) -> Self {
        Property::Number(value)
    }
}

impl From<i32> for Property {
    fn from(value: i32) -> Self {
        Property::Integer(value)
    }
}

impl From<bool> for Property {
    fn from(value: bool) -> Self {
        Property::Boolean(value)
    }
}

impl From<Color> for Property {
    fn from(value: Color) -> Self {
        Property::Color(value)
    }
}

impl From<EdgeInsets> for Property {
    fn from(value: EdgeInsets) -> Self {
        Property::EdgeInsets(value)
    }
}

impl From<Gradient> for Property {
    fn from(value: Gradient) -> Self {
        Property::Gradient(value)
    }
}

impl From<ShadowEffect> for Property {
    fn from(value: ShadowEffect) -> Self {
        Property::ShadowEffect(value)
    }
}

impl From<FontWeight> for Property {
    fn from(value: FontWeight) -> Self {
        Property::FontWeight(value)
    }
}

impl From<FontSlant> for Property {
    fn from(value: FontSlant) -> Self {
        Property::FontSlant(value)
    }
}

impl From<FontWidth> for Property {
    fn from(value: FontWidth) -> Self {
        Property::FontWidth(value)
    }
}

impl From<FontFeatures> for Property {
    fn from(value: FontFeatures) -> Self {
        Property::FontFeatures(value)
    }
}

impl From<BorderStyle> for Property {
    fn from(value: BorderStyle) -> Self {
        Property::BorderStyle(value)
    }
}

impl From<TextAlign> for Property {
    fn from(value: TextAlign) -> Self {
        Property::TextAlign(value)
    }
}

impl From<TextTransform> for Property {
    fn from(value: TextTransform) -> Self {
        Property::TextTransform(value)
    }
}

impl From<Overflow> for Property {
    fn from(value: Overflow) -> Self {
        Property::Overflow(value)
    }
}

impl From<Vec<Property>> for Property {
    fn from(value: Vec<Property>) -> Self {
        Property::Array(value)
    }
}

impl From<HashMap<String, Property>> for Property {
    fn from(value: HashMap<String, Property>) -> Self {
        Property::Map(value)
    }
}

/// A collection of strongly-typed properties
#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]
pub struct PropertyBag {
    properties: HashMap<String, Property>,
}

impl PropertyBag {
    /// Creates a new, empty PropertyBag
    pub fn new() -> Self {
        Self {
            properties: HashMap::new(),
        }
    }

    /// Sets a property with the given key and value.
    /// The value is converted to a Property using the Into trait.
    pub fn set<T: Into<Property>>(&mut self, key: &str, value: T) {
        self.properties.insert(key.to_string(), value.into());
    }

    /// Gets a property with the given key
    pub fn get(&self, key: &str) -> Option<&Property> {
        self.properties.get(key)
    }

    /// Gets a property as a string if it exists and is a string property
    pub fn get_string(&self, key: &str) -> Option<&String> {
        self.get(key).and_then(|prop| prop.as_string())
    }

    /// Gets a property as a number if it exists and is a number property
    pub fn get_number(&self, key: &str) -> Option<f32> {
        self.get(key).and_then(|prop| prop.as_number())
    }

    /// Gets a property as an integer if it exists and is an integer property
    pub fn get_integer(&self, key: &str) -> Option<i32> {
        self.get(key).and_then(|prop| prop.as_integer())
    }

    /// Gets a property as a boolean if it exists and is a boolean property
    pub fn get_boolean(&self, key: &str) -> Option<bool> {
        self.get(key).and_then(|prop| prop.as_boolean())
    }

    /// Gets a property as a Color if it exists and is a color property
    pub fn get_color(&self, key: &str) -> Option<&Color> {
        self.get(key).and_then(|prop| prop.as_color())
    }

    /// Gets a property as an EdgeInsets if it exists and is an edge insets property
    pub fn get_edge_insets(&self, key: &str) -> Option<&EdgeInsets> {
        self.get(key).and_then(|prop| prop.as_edge_insets())
    }

    /// Gets a property as a Gradient if it exists and is a gradient property
    pub fn get_gradient(&self, key: &str) -> Option<&Gradient> {
        self.get(key).and_then(|prop| prop.as_gradient())
    }

    /// Gets a property as a ShadowEffect if it exists and is a shadow effect property
    pub fn get_shadow_effect(&self, key: &str) -> Option<&ShadowEffect> {
        self.get(key).and_then(|prop| prop.as_shadow_effect())
    }

    /// Gets a property as a FontWeight if it exists and is a font weight property
    pub fn get_font_weight(&self, key: &str) -> Option<&FontWeight> {
        self.get(key).and_then(|prop| prop.as_font_weight())
    }

    /// Gets a property as a FontSlant if it exists and is a font slant property
    pub fn get_font_slant(&self, key: &str) -> Option<&FontSlant> {
        self.get(key).and_then(|prop| prop.as_font_slant())
    }

    /// Gets a property as a FontWidth if it exists and is a font width property
    pub fn get_font_width(&self, key: &str) -> Option<&FontWidth> {
        self.get(key).and_then(|prop| prop.as_font_width())
    }

    /// Gets a property as a FontFeatures if it exists and is a font features property
    pub fn get_font_features(&self, key: &str) -> Option<&FontFeatures> {
        self.get(key).and_then(|prop| prop.as_font_features())
    }

    /// Gets a property as a BorderStyle if it exists and is a border style property
    pub fn get_border_style(&self, key: &str) -> Option<&BorderStyle> {
        self.get(key).and_then(|prop| prop.as_border_style())
    }

    /// Gets a property as a TextAlign if it exists and is a text align property
    pub fn get_text_align(&self, key: &str) -> Option<&TextAlign> {
        self.get(key).and_then(|prop| prop.as_text_align())
    }

    /// Gets a property as a TextTransform if it exists and is a text transform property
    pub fn get_text_transform(&self, key: &str) -> Option<&TextTransform> {
        self.get(key).and_then(|prop| prop.as_text_transform())
    }

    /// Gets a property as an Overflow if it exists and is an overflow property
    pub fn get_overflow(&self, key: &str) -> Option<&Overflow> {
        self.get(key).and_then(|prop| prop.as_overflow())
    }

    /// Gets a property as a Vec<Property> if it exists and is an array property
    pub fn get_array(&self, key: &str) -> Option<&Vec<Property>> {
        self.get(key).and_then(|prop| prop.as_array())
    }

    /// Gets a property as a HashMap<String, Property> if it exists and is a map property
    pub fn get_map(&self, key: &str) -> Option<&HashMap<String, Property>> {
        self.get(key).and_then(|prop| prop.as_map())
    }

    /// Checks if a property exists
    pub fn has(&self, key: &str) -> bool {
        self.properties.contains_key(key)
    }

    /// Removes a property and returns it if it exists
    pub fn remove(&mut self, key: &str) -> Option<Property> {
        self.properties.remove(key)
    }

    /// Returns an iterator over the property keys
    pub fn keys(&self) -> impl Iterator<Item = &String> {
        self.properties.keys()
    }

    /// Returns an iterator over the property values
    pub fn values(&self) -> impl Iterator<Item = &Property> {
        self.properties.values()
    }

    /// Returns an iterator over the property entries (key-value pairs)
    pub fn entries(&self) -> impl Iterator<Item = (&String, &Property)> {
        self.properties.iter()
    }

    /// Returns the number of properties in the bag
    pub fn len(&self) -> usize {
        self.properties.len()
    }

    /// Checks if the property bag is empty
    pub fn is_empty(&self) -> bool {
        self.properties.is_empty()
    }
    
    /// Gets a property as a string value regardless of its type
    pub fn get_as_string(&self, key: &str) -> Option<String> {
        self.get(key).map(|prop| prop.to_string_value())
    }
    
    /// Creates a PropertyBag from a HashMap<String, String>
    /// This is useful for migrating from the old property system
    pub fn from_string_map(map: &HashMap<String, String>) -> Self {
        let mut bag = Self::new();
        for (key, value) in map {
            // Try to parse as various types
            if let Ok(num) = value.parse::<f32>() {
                bag.set(key, Property::Number(num));
            } else if let Ok(bool_val) = value.parse::<bool>() {
                bag.set(key, Property::Boolean(bool_val));
            } else if let Some(edge_insets) = crate::shared::edge_insets::parse_edge_insets(value) {
                bag.set(key, Property::EdgeInsets(edge_insets));
            } else {
                bag.set(key, Property::String(value.clone()));
            }
        }
        bag
    }
    
    /// Converts the PropertyBag to a HashMap<String, String>
    /// This is useful for backward compatibility
    pub fn to_string_map(&self) -> HashMap<String, String> {
        let mut map = HashMap::new();
        for (key, value) in &self.properties {
            map.insert(key.clone(), value.to_string_value());
        }
        map
    }
    
    /// Merges another PropertyBag into this one
    pub fn merge(&mut self, other: &PropertyBag) {
        for (key, value) in other.entries() {
            self.properties.insert(key.clone(), value.clone());
        }
    }
    
    /// Creates a new PropertyBag with the merged properties
    pub fn merged(self, other: &PropertyBag) -> Self {
        let mut result = self;
        result.merge(other);
        result
    }
}

/// Provides utility functions for working with properties
pub mod utils {
    use super::*;
    
    /// Sets an optional property on a PropertyBag
    pub fn set_optional_prop<T: Into<Property> + Clone>(
        bag: &mut PropertyBag, 
        key: &str, 
        value: &Option<T>
    ) {
        if let Some(val) = value {
            bag.set(key, val.clone());
        }
    }
    
    /// Parses a string value into a typed property if possible
    pub fn parse_property_value(value: &str) -> Property {
        // Try to parse as boolean
        if value == "true" || value == "false" {
            if let Ok(bool_val) = value.parse::<bool>() {
                return Property::Boolean(bool_val);
            }
        }
        
        // Try to parse as number
        if let Ok(num_val) = value.parse::<f32>() {
            return Property::Number(num_val);
        }
        
        // Try to parse as edge insets
        if let Some(insets) = crate::shared::edge_insets::parse_edge_insets(value) {
            return Property::EdgeInsets(insets);
        }
        
        // Default to string
        Property::String(value.to_string())
    }
    
    /// Gets a property with a default value
    pub fn get_property_with_default<T>(
        bag: &PropertyBag,
        key: &str,
        extractor: fn(&Property) -> Option<T>,
        default: T
    ) -> T {
        bag.get(key).and_then(extractor).unwrap_or(default)
    }
```

## File: base_props.rs

```rs
use crate::shared::color::Color;
use crate::styles::{BorderStyle, ShadowEffect, Gradient};
use crate::EdgeInsets;
use std::fmt;
use serde::{Serialize, Deserialize};

/// BaseComponentProps provides a set of common properties shared by all UI components.
/// This structure centralizes the definition of properties that apply to most or all
/// component types, promoting consistency and reducing code duplication.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct BaseComponentProps {
    // Identification
    pub id: Option<String>,
    
    // Visual properties
    pub background: Option<Color>,
    pub opacity: Option<f32>,
    
    // Layout properties
    pub padding: Option<f32>,
    pub edge_insets: Option<EdgeInsets>,
    pub width: Option<f32>,
    pub height: Option<f32>,
    pub min_width: Option<f32>,
    pub max_width: Option<f32>,
    pub min_height: Option<f32>,
    pub max_height: Option<f32>,
    
    // Border properties
    pub border_width: Option<f32>,
    pub border_color: Option<Color>,
    pub border_radius: Option<f32>,
    pub border_style: Option<BorderStyle>,
    
    // Shadow properties
    pub shadow_radius: Option<f32>,
    pub shadow_color: Option<Color>,
    pub shadow_offset_x: Option<f32>,
    pub shadow_offset_y: Option<f32>,
    
    // Advanced visual properties
    pub gradient: Option<Gradient>,
    pub clip_to_bounds: Option<bool>,
    pub shadow_effect: Option<ShadowEffect>,
    
    // Interaction properties
    pub enabled: Option<bool>,
    pub focusable: Option<bool>,
    
    // Accessibility properties
    pub accessibility_label: Option<String>,
    pub accessibility_hint: Option<String>,
    pub is_accessibility_element: Option<bool>,
    
    // Animation properties
    pub animation_duration: Option<f32>,
    pub transition_properties: Option<Vec<String>>,
}

impl Default for BaseComponentProps {
    fn default() -> Self {
        Self {
            id: None,
            background: None,
            opacity: None,
            padding: None,
            edge_insets: None,
            width: None,
            height: None,
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None,
            border_width: None,
            border_color: None,
            border_radius: None,
            border_style: None,
            shadow_radius: None,
            shadow_color: None,
            shadow_offset_x: None,
            shadow_offset_y: None,
            gradient: None,
            clip_to_bounds: None,
            shadow_effect: None,
            enabled: None,
            focusable: None,
            accessibility_label: None,
            accessibility_hint: None,
            is_accessibility_element: None,
            animation_duration: None,
            transition_properties: None,
        }
    }
}

impl BaseComponentProps {
    /// Create a new instance with default values
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Create a new instance with a specific ID
    pub fn with_id(id: &str) -> Self {
        let mut props = Self::default();
        props.id = Some(id.to_string());
        props
    }
    
    // Builder methods for visual properties
    
    /// Set the background color
    pub fn with_background(mut self, color: Color) -> Self {
        self.background = Some(color);
        self
    }
    
    /// Set the opacity (0.0 - 1.0)
    pub fn with_opacity(mut self, opacity: f32) -> Self {
        self.opacity = Some(opacity.max(0.0).min(1.0));
        self
    }
    
    // Builder methods for layout properties
    
    /// Set uniform padding on all sides
    pub fn with_padding(mut self, padding: f32) -> Self {
        self.padding = Some(padding);
        self
    }
    
    /// Set detailed edge insets (top, right, bottom, left)
    pub fn with_edge_insets(mut self, insets: EdgeInsets) -> Self {
        self.edge_insets = Some(insets);
        self
    }
    
    /// Set the fixed width
    pub fn with_width(mut self, width: f32) -> Self {
        self.width = Some(width);
        self
    }
    
    /// Set the fixed height
    pub fn with_height(mut self, height: f32) -> Self {
        self.height = Some(height);
        self
    }
    
    /// Set both width and height
    pub fn with_size(mut self, width: f32, height: f32) -> Self {
        self.width = Some(width);
        self.height = Some(height);
        self
    }
    
    /// Set the minimum width
    pub fn with_min_width(mut self, min_width: f32) -> Self {
        self.min_width = Some(min_width);
        self
    }
    
    /// Set the maximum width
    pub fn with_max_width(mut self, max_width: f32) -> Self {
        self.max_width = Some(max_width);
        self
    }
    
    /// Set the minimum height
    pub fn with_min_height(mut self, min_height: f32) -> Self {
        self.min_height = Some(min_height);
        self
    }
    
    /// Set the maximum height
    pub fn with_max_height(mut self, max_height: f32) -> Self {
        self.max_height = Some(max_height);
        self
    }
    
    // Builder methods for border properties
    
    /// Set the border width
    pub fn with_border_width(mut self, width: f32) -> Self {
        self.border_width = Some(width);
        self
    }
    
    /// Set the border color
    pub fn with_border_color(mut self, color: Color) -> Self {
        self.border_color = Some(color);
        self
    }
    
    /// Set the border radius (for rounded corners)
    pub fn with_border_radius(mut self, radius: f32) -> Self {
        self.border_radius = Some(radius);
        self
    }
    
    /// Set the border style
    pub fn with_border_style(mut self, style: BorderStyle) -> Self {
        self.border_style = Some(style);
        self
    }
    
    /// Set all border properties at once
    pub fn with_border(mut self, width: f32, color: Color, radius: f32, style: BorderStyle) -> Self {
        self.border_width = Some(width);
        self.border_color = Some(color);
        self.border_radius = Some(radius);
        self.border_style = Some(style);
        self
    }
    
    // Builder methods for shadow properties
    
    /// Set the shadow radius (blur)
    pub fn with_shadow_radius(mut self, radius: f32) -> Self {
        self.shadow_radius = Some(radius);
        self
    }
    
    /// Set the shadow color
    pub fn with_shadow_color(mut self, color: Color) -> Self {
        self.shadow_color = Some(color);
        self
    }
    
    /// Set the shadow offset (x and y)
    pub fn with_shadow_offset(mut self, offset_x: f32, offset_y: f32) -> Self {
        self.shadow_offset_x = Some(offset_x);
        self.shadow_offset_y = Some(offset_y);
        self
    }
    
    /// Set all shadow properties at once
    pub fn with_shadow(mut self, radius: f32, color: Color, offset_x: f32, offset_y: f32) -> Self {
        self.shadow_radius = Some(radius);
        self.shadow_color = Some(color);
        self.shadow_offset_x = Some(offset_x);
        self.shadow_offset_y = Some(offset_y);
        self
    }
    
    /// Set a complex shadow effect
    pub fn with_shadow_effect(mut self, effect: ShadowEffect) -> Self {
        self.shadow_effect = Some(effect);
        self
    }
    
    // Builder methods for advanced visual properties
    
    /// Set a gradient
    pub fn with_gradient(mut self, gradient: Gradient) -> Self {
        self.gradient = Some(gradient);
        self
    }
    
    /// Set whether content should be clipped to bounds
    pub fn with_clip_to_bounds(mut self, clip: bool) -> Self {
        self.clip_to_bounds = Some(clip);
        self
    }
    
    // Builder methods for interaction properties
    
    /// Set whether the component is enabled
    pub fn with_enabled(mut self, enabled: bool) -> Self {
        self.enabled = Some(enabled);
        self
    }
    
    /// Set whether the component can receive focus
    pub fn with_focusable(mut self, focusable: bool) -> Self {
        self.focusable = Some(focusable);
        self
    }
    
    // Builder methods for accessibility properties
    
    /// Set the accessibility label
    pub fn with_accessibility_label(mut self, label: &str) -> Self {
        self.accessibility_label = Some(label.to_string());
        self
    }
    
    /// Set the accessibility hint
    pub fn with_accessibility_hint(mut self, hint: &str) -> Self {
        self.accessibility_hint = Some(hint.to_string());
        self
    }
    
    /// Set whether this is an accessibility element
    pub fn with_is_accessibility_element(mut self, is_element: bool) -> Self {
        self.is_accessibility_element = Some(is_element);
        self
    }
    
    /// Set all accessibility properties at once
    pub fn with_accessibility(mut self, label: &str, hint: &str, is_element: bool) -> Self {
        self.accessibility_label = Some(label.to_string());
        self.accessibility_hint = Some(hint.to_string());
        self.is_accessibility_element = Some(is_element);
        self
    }
    
    // Builder methods for animation properties
    
    /// Set the animation duration
    pub fn with_animation_duration(mut self, duration: f32) -> Self {
        self.animation_duration = Some(duration);
        self
    }
    
    /// Set the properties that should animate during transitions
    pub fn with_transition_properties(mut self, properties: Vec<String>) -> Self {
        self.transition_properties = Some(properties);
        self
    }
    
    /// Add a property to animate during transitions
    pub fn add_transition_property(mut self, property: &str) -> Self {
        let mut props = self.transition_properties.unwrap_or_default();
        props.push(property.to_string());
        self.transition_properties = Some(props);
        self
    }
    
    /// Merge with another BaseComponentProps, with other properties taking precedence
    pub fn merge(self, other: &BaseComponentProps) -> Self {
        let mut result = self;
        
        // For each property in other, update result if Some
        if let Some(id) = &other.id { result.id = Some(id.clone()); }
        if let Some(background) = &other.background { result.background = Some(background.clone()); }
        if let Some(opacity) = &other.opacity { result.opacity = Some(*opacity); }
        if let Some(padding) = &other.padding { result.padding = Some(*padding); }
        if let Some(edge_insets) = &other.edge_insets { result.edge_insets = Some(edge_insets.clone()); }
        if let Some(width) = &other.width { result.width = Some(*width); }
        if let Some(height) = &other.height { result.height = Some(*height); }
        if let Some(min_width) = &other.min_width { result.min_width = Some(*min_width); }
        if let Some(max_width) = &other.max_width { result.max_width = Some(*max_width); }
        if let Some(min_height) = &other.min_height { result.min_height = Some(*min_height); }
        if let Some(max_height) = &other.max_height { result.max_height = Some(*max_height); }
        if let Some(border_width) = &other.border_width { result.border_width = Some(*border_width); }
        if let Some(border_color) = &other.border_color { result.border_color = Some(border_color.clone()); }
        if let Some(border_radius) = &other.border_radius { result.border_radius = Some(*border_radius); }
        if let Some(border_style) = &other.border_style { result.border_style = Some(border_style.clone()); }
        if let Some(shadow_radius) = &other.shadow_radius { result.shadow_radius = Some(*shadow_radius); }
        if let Some(shadow_color) = &other.shadow_color { result.shadow_color = Some(shadow_color.clone()); }
        if let Some(shadow_offset_x) = &other.shadow_offset_x { result.shadow_offset_x = Some(*shadow_offset_x); }
        if let Some(shadow_offset_y) = &other.shadow_offset_y { result.shadow_offset_y = Some(*shadow_offset_y); }
        if let Some(gradient) = &other.gradient { result.gradient = Some(gradient.clone()); }
        if let Some(clip_to_bounds) = &other.clip_to_bounds { result.clip_to_bounds = Some(*clip_to_bounds); }
        if let Some(shadow_effect) = &other.shadow_effect { result.shadow_effect = Some(shadow_effect.clone()); }
        if let Some(enabled) = &other.enabled { result.enabled = Some(*enabled); }
        if let Some(focusable) = &other.focusable { result.focusable = Some(*focusable); }
        if let Some(accessibility_label) = &other.accessibility_label { result.accessibility_label = Some(accessibility_label.clone()); }
        if let Some(accessibility_hint) = &other.accessibility_hint { result.accessibility_hint = Some(accessibility_hint.clone()); }
        if let Some(is_accessibility_element) = &other.is_accessibility_element { result.is_accessibility_element = Some(*is_accessibility_element); }
        if let Some(animation_duration) = &other.animation_duration { result.animation_duration = Some(*animation_duration); }
        if let Some(transition_properties) = &other.transition_properties { result.transition_properties = Some(transition_properties.clone()); }
        
        result
    }
}

impl fmt::Display for BaseComponentProps {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "BaseComponentProps {{ ")?;
        
        if let Some(id) = &self.id {
            write!(f, "id: {}, ", id)?;
        }
        
        // Only include a few important properties in the display representation
        if let Some(background) = &self.background {
            write!(f, "background: {:?}, ", background)?;
        }
        
        if let Some(width) = &self.width {
            write!(f, "width: {}, ", width)?;
        }
        
        if let Some(height) = &self.height {
            write!(f, "height: {}, ", height)?;
        }
        
        write!(f, "... }}")
    }
}

/// Helper functions for working with BaseComponentProps
pub mod utils {
    use super::*;
    use crate::render::node::RenderNode;
    use crate::render::property;
    use crate::shared::properties::{Property, PropertyBag};
    use crate::styles::SpreadMethod;
    use crate::GradientType;
    
    /// Apply base properties to a render node
    pub fn apply_base_props(node: &mut RenderNode, base_props: &BaseComponentProps) {
        // Helper function to set a property if it's Some
        fn set_if_some_property<T>(node: &mut RenderNode, key: &str, value: &Option<T>) 
            where
                T: Clone + Into<Property>, property::Property: From<T>
            {
                if let Some(val) = value {
                    node.set_prop(key, val.clone());
                }
            }

        // Apply visual properties
        set_if_some_property(node, "background", &base_props.background);
        set_if_some_property(node, "opacity", &base_props.opacity);
        
        // Apply layout properties
        set_if_some_property(node, "padding", &base_props.padding);
        set_if_some_property(node, "edge_insets", &base_props.edge_insets);
        set_if_some_property(node, "width", &base_props.width);
        set_if_some_property(node, "height", &base_props.height);
        set_if_some_property(node, "min_width", &base_props.min_width);
        set_if_some_property(node, "max_width", &base_props.max_width);
        set_if_some_property(node, "min_height", &base_props.min_height);
        set_if_some_property(node, "max_height", &base_props.max_height);
        
        // Apply border properties
        set_if_some_property(node, "border_width", &base_props.border_width);
        set_if_some_property(node, "border_color", &base_props.border_color);
        set_if_some_property(node, "border_radius", &base_props.border_radius);
        if let Some(style) = &base_props.border_style {
            node.set_prop("border_style", format!("{:?}", style));
        }
        
        // Apply shadow properties
        set_if_some_property(node, "shadow_radius", &base_props.shadow_radius);
        set_if_some_property(node, "shadow_color", &base_props.shadow_color);
        set_if_some_property(node, "shadow_offset_x", &base_props.shadow_offset_x);
        set_if_some_property(node, "shadow_offset_y", &base_props.shadow_offset_y);
        
        // Apply advanced visual properties
        set_if_some_property(node, "clip_to_bounds", &base_props.clip_to_bounds);
        
        // Apply interaction properties
        set_if_some_property(node, "enabled", &base_props.enabled);
        set_if_some_property(node, "focusable", &base_props.focusable);
        
        // Apply accessibility properties
        set_if_some_property(node, "accessibility_label", &base_props.accessibility_label);
        set_if_some_property(node, "accessibility_hint", &base_props.accessibility_hint);
        set_if_some_property(node, "is_accessibility_element", &base_props.is_accessibility_element);
        
        // Apply animation properties
        set_if_some_property(node, "animation_duration", &base_props.animation_duration);
        
        // Handle complex properties

        // Gradient
        if let Some(gradient) = &base_props.gradient {
            // Set gradient type based on the GradientType enum
            let gradient_type_str = match gradient.gradient_type {
                GradientType::Linear => "linear",
                GradientType::Radial => "radial",
                GradientType::Conic => "conic",
                GradientType::Repeating => "repeating",
            };
            node.set_prop("gradient_type", gradient_type_str);
            
            // Set gradient stops
            node.set_prop("gradient_stop_count", gradient.stops.len().to_string());
            for (i, stop) in gradient.stops.iter().enumerate() {
                node.set_prop(&format!("gradient_stop_{}_color", i), stop.color.clone());
                node.set_prop(&format!("gradient_stop_{}_position", i), stop.position.to_string());
                if let Some(name) = &stop.name {
                    node.set_prop(&format!("gradient_stop_{}_name", i), name.clone());
                }
            }
            
            // Set gradient endpoints
            node.set_prop("gradient_start_x", gradient.start_point.0.to_string());
            node.set_prop("gradient_start_y", gradient.start_point.1.to_string());
            node.set_prop("gradient_end_x", gradient.end_point.0.to_string());
            node.set_prop("gradient_end_y", gradient.end_point.1.to_string());
            
            // Set optional properties
            if let Some(angle) = gradient.angle {
                node.set_prop("gradient_angle", angle.to_string());
            }
            
            if let Some(spread) = &gradient.spread_method {
                let spread_str = match spread {
                    SpreadMethod::Pad => "pad",
                    SpreadMethod::Reflect => "reflect",
                    SpreadMethod::Repeat => "repeat",
                };
                node.set_prop("gradient_spread_method", spread_str);
            }
            
            if let Some(name) = &gradient.name {
                node.set_prop("gradient_name", name.to_string());
            }
            
            if let Some(custom_props) = &gradient.custom_props {
                for (key, value) in custom_props {
                    node.set_prop(&format!("gradient_custom_{}", key), value.to_string());
                }
            }
        }
        
        // Shadow effect
        if let Some(effect) = &base_props.shadow_effect {
            node.set_prop("shadow_effect_color", effect.color.clone());
            node.set_prop("shadow_effect_offset_x", effect.offset.0.to_string());
            node.set_prop("shadow_effect_offset_y", effect.offset.1.to_string());
            node.set_prop("shadow_effect_blur_radius", effect.blur_radius.to_string());
            
            if let Some(spread) = effect.spread_radius {
                node.set_prop("shadow_effect_spread_radius", spread.to_string());
            }
            
            if let Some(inset) = effect.inset {
                node.set_prop("shadow_effect_inset", inset.to_string());
            }
            
            if let Some(opacity) = effect.opacity {
                node.set_prop("shadow_effect_opacity", opacity.to_string());
            }
            
            if let Some(name) = &effect.name {
                node.set_prop("shadow_effect_name", name.to_string());
            }
            
            if let Some(z_index) = effect.z_index {
                node.set_prop("shadow_effect_z_index", z_index.to_string());
            }
        }
        
        // Transition properties
        if let Some(transition_props) = &base_props.transition_properties {
            node.set_prop("transition_property_count", transition_props.len().to_string());
            
            for (i, prop) in transition_props.iter().enumerate() {
                node.set_prop(&format!("transition_property_{}", i), prop.clone());
            }
        }
    }
    
    /// Extract base properties from a PropertyBag
    pub fn extract_base_props(properties: &PropertyBag) -> BaseComponentProps {
        let mut base_props = BaseComponentProps::new();
        
        // Helper function to extract and convert properties
        let extract = |properties: &PropertyBag, key: &str| -> Option<Property> {
            properties.get(key).cloned()
        };
        
        // Extract visual properties
        if let Some(Property::String(id)) = extract(properties, "id") {
            base_props.id = Some(id);
        }
        
        if let Some(Property::Color(color)) = extract(properties, "background") {
            base_props.background = Some(color);
        }
        
        if let Some(Property::Number(opacity)) = extract(properties, "opacity") {
            base_props.opacity = Some(opacity);
        }
        
        // Extract layout properties
        if let Some(Property::Number(padding)) = extract(properties, "padding") {
            base_props.padding = Some(padding);
        }
        
        if let Some(Property::EdgeInsets(insets)) = extract(properties, "edge_insets") {
            base_props.edge_insets = Some(insets);
        }
        
        if let Some(Property::Number(width)) = extract(properties, "width") {
            base_props.width = Some(width);
        }
        
        if let Some(Property::Number(height)) = extract(properties, "height") {
            base_props.height = Some(height);
        }
        
        if let Some(Property::Number(min_width)) = extract(properties, "min_width") {
            base_props.min_width = Some(min_width);
        }
        
        if let Some(Property::Number(max_width)) = extract(properties, "max_width") {
            base_props.max_width = Some(max_width);
        }
        
        if let Some(Property::Number(min_height)) = extract(properties, "min_height") {
            base_props.min_height = Some(min_height);
        }
        
        if let Some(Property::Number(max_height)) = extract(properties, "max_height") {
            base_props.max_height = Some(max_height);
        }

        if let Some(Property::Number(border_width)) = extract(properties, "border_width") {
            base_props.border_width = Some(border_width);
        }
        
        if let Some(Property::Color(border_color)) = extract(properties, "border_color") {
            base_props.border_color = Some(border_color);
        }
        
        if let Some(Property::Number(border_radius)) = extract(properties, "border_radius") {
            base_props.border_radius = Some(border_radius);
        }
        
        base_props
    }
```

## File: layout_utils.rs

```rs
use crate::render::node::RenderNode;
use crate::shared::edge_insets::{EdgeInsets, parse_edge_insets as parse_insets_from_string};

/// Extract edge insets from a render node
pub fn parse_edge_insets(node: &RenderNode) -> EdgeInsets {
    // First try to get directly from strongly typed property
    if let Some(property) = node.get_prop("edge_insets") {
        if let Some(insets) = property.as_edge_insets() {
            return *insets;
        }
        
        // Try to parse from string representation
        if let Some(insets_str) = property.as_string() {
            if let Some(insets) = parse_insets_from_string(insets_str) {
                return insets;
            }
        }
    }
    
    // Check for direct string property (backward compatibility)
    if let Some(insets_str) = node.get_prop_string("edge_insets") {
        if let Some(insets) = parse_insets_from_string(insets_str) {
            return insets;
        }
    }
    
    // Try padding as a fallback
    if let Some(padding) = node.get_prop_f32("padding") {
        EdgeInsets::all(padding)
    } else {
        EdgeInsets::zero()
    }
}
```

## File: event_system.rs

```rs
use serde::{Serialize, Deserialize};
use std::any::Any;
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

use super::event_types::EventMetadata;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EventPhase {
    Capturing,
    AtTarget,
    Bubbling,
}

pub trait EventPayload: Any + Send + Sync {
    fn as_any(&self) -> &dyn Any;
    
    fn clone_box(&self) -> Box<dyn EventPayload>;
}

impl Clone for Box<dyn EventPayload> {
    fn clone(&self) -> Self {
        self.clone_box()
    }
}

#[derive(Clone)]
pub struct GenericPayload<T: Clone + 'static> {
    pub value: T,
}

impl<T: Clone + 'static + std::marker::Sync + std::marker::Send> EventPayload for GenericPayload<T> {
    fn as_any(&self) -> &dyn Any {
        self
    }
    
    fn clone_box(&self) -> Box<dyn EventPayload> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum EventType {
    Tap,
    DoubleTap,
    LongPress,
    
    PointerDown,
    PointerUp,
    PointerMove,
    
    TouchStart,
    TouchEnd,
    TouchMove,
    
    Focus,
    Blur,
    
    HoverEnter,
    HoverExit,
    
    ValueChange,
    Submit,
    
    Swipe(SwipeDirection),
    Pinch,
    Rotate,
    
    DragStart,
    Drag,
    DragEnd,
    
    KeyDown,
    KeyUp,
    
    LoadingStart,
    LoadingEnd,
    
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum SwipeDirection {
    Left,
    Right,
    Up,
    Down,
}

#[derive(Clone)]
pub struct Event {
    pub id: String,
    
    pub event_type: EventType,
    
    pub timestamp: u128,
    
    pub phase: EventPhase,
    
    pub position: Option<(f32, f32)>,
    
    pub target_id: Option<String>,
    
    pub properties: HashMap<String, String>,
    
    pub payload: Option<Box<dyn EventPayload>>,
    
    pub metadata: EventMetadata,
    
    pub is_stopped: bool,
    pub is_prevented: bool,
}

impl Event {
    pub fn new(event_type: EventType, source: super::event_types::EventSource) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            event_type,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .map(|d| d.as_millis())
                .unwrap_or(0),
            phase: EventPhase::Capturing,
            position: None,
            target_id: None,
            properties: HashMap::new(),
            payload: None,
            metadata: EventMetadata::new(source),
            is_stopped: false,
            is_prevented: false,
        }
    }
    
    pub fn with_position(mut self, x: f32, y: f32) -> Self {
        self.position = Some((x, y));
        self
    }
    
    pub fn with_target(mut self, target_id: String) -> Self {
        self.target_id = Some(target_id);
        self
    }
    
    pub fn with_property(mut self, key: &str, value: &str) -> Self {
        self.properties.insert(key.to_string(), value.to_string());
        self
    }
    
    pub fn with_payload<T: EventPayload>(mut self, payload: T) -> Self {
        self.payload = Some(Box::new(payload));
        self
    }
    
    pub fn stop_propagation(&mut self) {
        self.is_stopped = true;
    }
    
    pub fn prevent_default(&mut self) {
        self.is_prevented = true;
    }
    
    pub fn get_payload<T: 'static>(&self) -> Option<&T> {
        self.payload
            .as_ref()
            .and_then(|payload| payload.as_any().downcast_ref())
    }
}

impl Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(Serialize)]
        struct SerializableEvent<'a> {
            id: &'a str,
            event_type: &'a EventType,
            timestamp: u128,
            phase: &'a EventPhase,
            position: Option<(f32, f32)>,
            target_id: Option<&'a str>,
            properties: &'a HashMap<String, String>,
            metadata: &'a EventMetadata,
            is_stopped: bool,
            is_prevented: bool,
        }

        let serializable = SerializableEvent {
            id: &self.id,
            event_type: &self.event_type,
            timestamp: self.timestamp,
            phase: &self.phase,
            position: self.position,
            target_id: self.target_id.as_deref(),
            properties: &self.properties,
            metadata: &self.metadata,
            is_stopped: self.is_stopped,
            is_prevented: self.is_prevented,
        };

        serializable.serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct SerializableEvent {
            id: String,
            event_type: EventType,
            timestamp: u128,
            phase: EventPhase,
            position: Option<(f32, f32)>,
            target_id: Option<String>,
            properties: HashMap<String, String>,
            metadata: EventMetadata,
            is_stopped: bool,
            is_prevented: bool,
        }

        let event = SerializableEvent::deserialize(deserializer)?;

        Ok(Event {
            id: event.id,
            event_type: event.event_type,
            timestamp: event.timestamp,
            phase: event.phase,
            position: event.position,
            target_id: event.target_id,
            properties: event.properties,
            payload: None,
            metadata: event.metadata,
            is_stopped: event.is_stopped,
