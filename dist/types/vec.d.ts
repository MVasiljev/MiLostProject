import { Option } from "../core/option";
import { u32 } from "../types/primitives";
import { Str } from "../types/string";
export declare class Vec<T> implements Iterable<T> {
    private readonly _items;
    private readonly _inner;
    private readonly _useWasm;
    private readonly _isNumeric;
    private constructor();
    static new<T>(): Vec<T>;
    static empty<T>(): Vec<T>;
    static from<T>(iterable: Iterable<T>): Vec<T>;
    static withCapacity<T>(capacity: number): Promise<Vec<T>>;
    static create<T>(items?: T[]): Promise<Vec<T>>;
    len(): u32;
    isEmpty(): boolean;
    get(index: u32): Option<T>;
    set(index: u32, value: T): Vec<T>;
    push(item: T): Vec<T>;
    pop(): [Vec<T>, Option<T>];
    toArray(): T[];
    find(predicate: (item: T) => boolean): Option<T>;
    fold<R>(initial: R, fn: (acc: R, item: T, index: u32) => R): R;
    map<U>(fn: (item: T, index: u32) => U): Vec<U>;
    filter(predicate: (item: T, index: u32) => boolean): Vec<T>;
    reverse(): Vec<T>;
    all(predicate: (item: T) => boolean): boolean;
    any(predicate: (item: T) => boolean): boolean;
    take(n: u32): Vec<T>;
    drop(n: u32): Vec<T>;
    concat(other: Vec<T>): Vec<T>;
    [Symbol.iterator](): Iterator<T>;
    toString(): Str;
    toJSON(): T[];
    get [Symbol.toStringTag](): Str;
}
