            is_prevented: event.is_prevented,
        })
    }
}

impl Event {
    pub fn tap(source: super::event_types::EventSource) -> Self {
        Self::new(EventType::Tap, source)
    }

    pub fn double_tap(source: super::event_types::EventSource) -> Self {
        Self::new(EventType::DoubleTap, source)
    }

    pub fn long_press(source: super::event_types::EventSource) -> Self {
        Self::new(EventType::LongPress, source)
    }
```

## File: event_types.rs

```rs
use std::any::Any;
use std::collections::HashMap;
use std::fmt::{self, Debug, Display};
use std::hash::{Hash, Hasher};
use std::time::{SystemTime, UNIX_EPOCH, Duration, Instant};
use serde::{Serialize, Deserialize, ser::{Serializer, SerializeStruct}, de::{self, Deserializer, Visitor}};
use uuid::Uuid;

#[derive(Debug, Clone)]
pub enum EventError {
    SerializationError(String),
    DeserializationError(String),
    PayloadError(String),
    ValidationError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EventSource {
    Mouse {
        button: Option<MouseButton>,
    },
    Touch {
        multi_touch: bool,
        pressure: Option<f32>,
    },
    Pointer {
        pointer_type: PointerType,
    },
    Keyboard {
        is_virtual: bool,
    },
    GamePad {
        connection_type: GamePadConnectionType,
    },
    VirtualReality {
        tracking_space: TrackingSpace,
    },
    Custom {
        category: String,
        subcategory: Option<String>,
    },
}

impl Eq for EventSource {}

impl Hash for EventSource {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            Self::Mouse { button } => {
                0u8.hash(state);
                button.hash(state);
            },
            Self::Touch { multi_touch, pressure } => {
                1u8.hash(state);
                multi_touch.hash(state);
                
                if let Some(p) = pressure {
                    p.to_bits().hash(state);
                } else {
                    Option::<u32>::None.hash(state);
                }
            },
            Self::Pointer { pointer_type } => {
                2u8.hash(state);
                pointer_type.hash(state);
            },
            Self::Keyboard { is_virtual } => {
                3u8.hash(state);
                is_virtual.hash(state);
            },
            Self::GamePad { connection_type } => {
                4u8.hash(state);
                connection_type.hash(state);
            },
            Self::VirtualReality { tracking_space } => {
                5u8.hash(state);
                tracking_space.hash(state);
            },
            Self::Custom { category, subcategory } => {
                6u8.hash(state);
                category.hash(state);
                subcategory.hash(state);
            },
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum MouseButton {
    Left,
    Right,
    Middle,
    Additional(u8),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum PointerType {
    Mouse,
    Pen,
    Touch,
    Eraser,
    Camera,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum GamePadConnectionType {
    Wired,
    Bluetooth,
    Wireless,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum TrackingSpace {
    Standing,
    Seated,
    RoomScale,
    Custom(String),
}

#[derive(Debug, Clone)]
pub struct EventMetadata {
    pub id: String,
    pub timestamp: Instant,
    pub system_timestamp: u128,
    pub source: EventSource,
    pub device_id: Option<String>,
    pub context: HashMap<String, String>,
    pub trace_id: Option<String>,
}

impl EventMetadata {
    pub fn new(source: EventSource) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            timestamp: Instant::now(),
            system_timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .map(|d| d.as_millis())
                .unwrap_or(0),
            source,
            device_id: None,
            context: HashMap::new(),
            trace_id: None,
        }
    }
    
    pub fn with_trace_id(mut self, trace_id: String) -> Self {
        self.trace_id = Some(trace_id);
        self
    }
    
    pub fn add_performance_context(&mut self, key: &str, value: &str) {
        self.context.insert(format!("perf_{}", key), value.to_string());
    }
    
    pub fn elapsed(&self) -> Duration {
        self.timestamp.elapsed()
    }
}

impl Serialize for EventMetadata {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut state = serializer.serialize_struct("EventMetadata", 7)?;
        state.serialize_field("id", &self.id)?;
        state.serialize_field("system_timestamp", &self.system_timestamp)?;
        state.serialize_field("source", &self.source)?;
        state.serialize_field("device_id", &self.device_id)?;
        state.serialize_field("context", &self.context)?;
        state.serialize_field("trace_id", &self.trace_id)?;
        state.end()
    }
}

impl<'de> Deserialize<'de> for EventMetadata {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        enum Field { 
            Id, 
            SystemTimestamp, 
            Source, 
            DeviceId, 
            Context, 
            TraceId 
        }

        impl<'de> Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>
            where D: Deserializer<'de> {
                struct FieldVisitor;

                impl<'de> Visitor<'de> for FieldVisitor {
                    type Value = Field;

                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter.write_str("`id`, `system_timestamp`, `source`, `device_id`, `context`, or `trace_id`")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Field, E>
                    where E: de::Error, {
                        match value {
                            "id" => Ok(Field::Id),
                            "system_timestamp" => Ok(Field::SystemTimestamp),
                            "source" => Ok(Field::Source),
                            "device_id" => Ok(Field::DeviceId),
                            "context" => Ok(Field::Context),
                            "trace_id" => Ok(Field::TraceId),
                            _ => Err(de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }

                deserializer.deserialize_identifier(FieldVisitor)
            }
        }

        struct EventMetadataVisitor;

        impl<'de> Visitor<'de> for EventMetadataVisitor {
            type Value = EventMetadata;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("struct EventMetadata")
            }

            fn visit_map<V>(self, mut map: V) -> Result<EventMetadata, V::Error>
            where V: de::MapAccess<'de>, {
                let mut id: Option<String> = None;
                let mut system_timestamp: Option<u128> = None;
                let mut source: Option<EventSource> = None;
                let mut device_id: Option<String> = None;
                let mut context: Option<HashMap<String, String>> = None;
                let mut trace_id: Option<String> = None;

                while let Some(key) = map.next_key()? {
                    match key {
                        Field::Id => {
                            if id.is_some() {
                                return Err(de::Error::duplicate_field("id"));
                            }
                            id = Some(map.next_value()?);
                        }
                        Field::SystemTimestamp => {
                            if system_timestamp.is_some() {
                                return Err(de::Error::duplicate_field("system_timestamp"));
                            }
                            system_timestamp = Some(map.next_value()?);
                        }
                        Field::Source => {
                            if source.is_some() {
                                return Err(de::Error::duplicate_field("source"));
                            }
                            source = Some(map.next_value()?);
                        }
                        Field::DeviceId => {
                            if device_id.is_some() {
                                return Err(de::Error::duplicate_field("device_id"));
                            }
                            device_id = Some(map.next_value()?);
                        }
                        Field::Context => {
                            if context.is_some() {
                                return Err(de::Error::duplicate_field("context"));
                            }
                            context = Some(map.next_value()?);
                        }
                        Field::TraceId => {
                            if trace_id.is_some() {
                                return Err(de::Error::duplicate_field("trace_id"));
                            }
                            trace_id = Some(map.next_value()?);
                        }
                    }
                }

                let source = source.ok_or_else(|| de::Error::missing_field("source"))?;
                let mut metadata = EventMetadata::new(source);
                
                if let Some(id) = id {
                    metadata.id = id;
                }
                metadata.system_timestamp = system_timestamp.unwrap_or(0);
                metadata.device_id = device_id;
                metadata.context = context.unwrap_or_default();
                metadata.trace_id = trace_id;

                Ok(metadata)
            }
        }

        const FIELDS: &'static [&'static str] = &[
            "id", 
            "system_timestamp", 
            "source", 
            "device_id", 
            "context", 
            "trace_id"
        ];
        
        deserializer.deserialize_struct("EventMetadata", FIELDS, EventMetadataVisitor)
    }
}

pub trait SafeEventPayload: Any + Send + Sync + Debug {
    fn as_any(&self) -> &dyn Any;
    
    fn clone_box(&self) -> Box<dyn SafeEventPayload>;
    
    fn validate(&self) -> Result<(), EventError>;
}

impl Clone for Box<dyn SafeEventPayload> {
    fn clone(&self) -> Self {
        self.clone_box()
    }
}

pub struct Payload<T: Clone + Debug + Send + Sync + 'static> {
    pub value: T,
    #[allow(unused)]
    pub validation_rules: Option<Box<dyn Fn(&T) -> Result<(), EventError> + Send + Sync>>,
}

impl<T: Clone + Debug + Send + Sync + 'static> Debug for Payload<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Payload")
            .field("value", &self.value)
            .field("validation_rules", &format_args!("{}", if self.validation_rules.is_some() { "Some(Fn)" } else { "None" }))
            .finish()
    }
}

impl<T: Clone + Debug + Send + Sync + 'static> Clone for Payload<T> {
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            validation_rules: None,
        }
    }
}

impl<T: Clone + Debug + Send + Sync + 'static> SafeEventPayload for Payload<T> {
    fn as_any(&self) -> &dyn Any {
        self
    }
    
    fn clone_box(&self) -> Box<dyn SafeEventPayload> {
        Box::new(self.clone())
    }
    
    fn validate(&self) -> Result<(), EventError> {
        if let Some(validator) = &self.validation_rules {
            validator(&self.value)
        } else {
            Ok(())
        }
    }
}

impl<T: Clone + Debug + Send + Sync + 'static> Payload<T> {
    pub fn new(value: T) -> Self {
        Self { 
            value, 
            validation_rules: None 
        }
    }
    
    pub fn with_validation(
        mut self, 
        validator: impl Fn(&T) -> Result<(), EventError> + Send + Sync + 'static
    ) -> Self {
        self.validation_rules = Some(Box::new(validator));
        self
    }
```

## File: node.rs

```rs
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::events::{EventType, ButtonEventHandler};
use crate::render::property::{Property, PropertyBag};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventHandler {
    pub event_type: EventType,
    pub handler_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeEventHandlers {
    pub on_tap: Option<String>,
    pub on_double_tap: Option<String>,
    pub on_long_press: Option<String>,
    pub on_hover_enter: Option<String>,
    pub on_hover_exit: Option<String>,
    pub on_focus: Option<String>,
    pub on_blur: Option<String>,
    pub on_value_change: Option<String>,
    pub on_submit: Option<String>,
    pub on_swipe: HashMap<String, String>,
}

impl Default for NodeEventHandlers {
    fn default() -> Self {
        Self {
            on_tap: None,
            on_double_tap: None,
            on_long_press: None,
            on_hover_enter: None,
            on_hover_exit: None,
            on_focus: None,
            on_blur: None,
            on_value_change: None,
            on_submit: None,
            on_swipe: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderNode {
    pub id: String,
    pub type_name: String,
    pub properties: PropertyBag,
    pub children: Vec<RenderNode>,
    pub event_handlers: Vec<EventHandler>,
    #[serde(default)]
    pub node_events: NodeEventHandlers,
}

impl RenderNode {
    pub fn new(id: &str, type_name: &str) -> Self {
        Self {
            id: id.to_string(),
            type_name: type_name.to_string(),
            properties: PropertyBag::new(),
            children: Vec::new(),
            event_handlers: Vec::new(),
            node_events: NodeEventHandlers::default(),
        }
    }

    pub fn add_event_handler(&mut self, handler: EventHandler) -> &mut Self {
        self.event_handlers.push(handler);
        self
    }

    pub fn on_event(&mut self, event_type: EventType, handler_id: &str) -> &mut Self {
        self.add_event_handler(EventHandler {
            event_type: event_type.clone(),
            handler_id: handler_id.to_string(),
        })
    }

    pub fn get_node_events(&self) -> Option<&NodeEventHandlers> {
        Some(&self.node_events)
    }

    pub fn on_tap(&mut self, handler_id: &str) -> &mut Self {
        self.on_event(EventType::Tap, handler_id);
        self.node_events.on_tap = Some(handler_id.to_string());
        self
    }

    pub fn on_double_tap(&mut self, handler_id: &str) -> &mut Self {
        self.on_event(EventType::DoubleTap, handler_id);
        self.node_events.on_double_tap = Some(handler_id.to_string());
        self
    }

    pub fn on_long_press(&mut self, handler_id: &str) -> &mut Self {
        self.on_event(EventType::LongPress, handler_id);
        self.node_events.on_long_press = Some(handler_id.to_string());
        self
    }

    pub fn on_hover_enter(&mut self, handler_id: &str) -> &mut Self {
        self.on_event(EventType::HoverEnter, handler_id);
        self.node_events.on_hover_enter = Some(handler_id.to_string());
        self
    }

    pub fn on_hover_exit(&mut self, handler_id: &str) -> &mut Self {
        self.on_event(EventType::HoverExit, handler_id);
        self.node_events.on_hover_exit = Some(handler_id.to_string());
        self
    }

    pub fn on_swipe(&mut self, direction: &str, handler_id: &str) -> &mut Self {
        use crate::events::SwipeDirection;
        
        let swipe_direction = match direction.to_lowercase().as_str() {
            "left" => SwipeDirection::Left,
            "right" => SwipeDirection::Right, 
            "up" => SwipeDirection::Up,
            "down" => SwipeDirection::Down,
            _ => return self,
        };
        
        self.on_event(EventType::Swipe(swipe_direction), handler_id);
        self.node_events.on_swipe.insert(direction.to_string(), handler_id.to_string());
        self
    }

    pub fn to_button_event_handler(&self) -> ButtonEventHandler {
        let mut handler = ButtonEventHandler::new();
        
        if let Some(ref tap_id) = self.node_events.on_tap {
            handler = handler.with_tap_handler(tap_id);
        }
        
        if let Some(ref double_tap_id) = self.node_events.on_double_tap {
            handler = handler.with_double_tap_handler(double_tap_id);
        }
        
        if let Some(ref long_press_id) = self.node_events.on_long_press {
            handler = handler.with_long_press_handler(long_press_id);
        }
        
        if let Some(ref hover_enter_id) = self.node_events.on_hover_enter {
            handler = handler.with_hover_enter_handler(hover_enter_id);
        }
        
        if let Some(ref hover_exit_id) = self.node_events.on_hover_exit {
            handler = handler.with_hover_exit_handler(hover_exit_id);
        }
        
        if let Some(ref focus_id) = self.node_events.on_focus {
            handler = handler.with_focus_handler(focus_id);
        }
        
        if let Some(ref blur_id) = self.node_events.on_blur {
            handler = handler.with_blur_handler(blur_id);
        }
        
        handler
    }
    
    pub fn add_child(&mut self, child: RenderNode) -> &mut Self {
        self.children.push(child);
        self
    }
    
    
    pub fn set_prop<T: Into<Property>>(&mut self, key: &str, value: T) -> &mut Self {
        self.properties.set(key, value);
        self
    }
    
    pub fn get_prop(&self, key: &str) -> Option<&Property> {
        self.properties.get(key)
    }
    
    pub fn get_prop_string(&self, key: &str) -> Option<&String> {
        self.properties.get_string(key)
    }
    
    pub fn get_prop_f32(&self, key: &str) -> Option<f32> {
        self.properties.get_number(key)
    }
    
    pub fn get_prop_bool(&self, key: &str) -> Option<bool> {
        self.properties.get_boolean(key)
    }
    
    pub fn get_prop_as_string(&self, key: &str) -> Option<String> {
        self.properties.get_as_string(key)
    }
    
    pub fn get_prop_compat(&self, key: &str) -> Option<String> {
        self.properties.get_as_string(key)
    }
    
    pub fn has_children(&self) -> bool {
        !self.children.is_empty()
    }
    
    pub fn child_count(&self) -> usize {
        self.children.len()
    }
    
    pub fn find_child_by_id(&self, id: &str) -> Option<&RenderNode> {
        if self.id == id {
            return Some(self);
        }
        
        for child in &self.children {
            if child.id == id {
                return Some(child);
            }
            
            if let Some(found) = child.find_child_by_id(id) {
                return Some(found);
            }
        }
        
        None
    }
    
    pub fn find_child_by_id_mut(&mut self, id: &str) -> Option<&mut RenderNode> {
        if self.id == id {
            return Some(self);
        }
        
        for child in &mut self.children {
            if child.id == id {
                return Some(child);
            }
            
            if let Some(found) = child.find_child_by_id_mut(id) {
                return Some(found);
            }
        }
        
        None
    }
    
    pub fn from_legacy(id: &str, type_name: &str, resolved_props: HashMap<String, String>, 
                      children: Vec<RenderNode>, event_handlers: Vec<EventHandler>,
                      node_events: NodeEventHandlers) -> Self {
        let properties = PropertyBag::from_string_map(&resolved_props);
        
        Self {
            id: id.to_string(),
            type_name: type_name.to_string(),
            properties,
            children,
            event_handlers,
            node_events,
        }
    }
    
    pub fn to_legacy_props(&self) -> HashMap<String, String> {
        self.properties.to_string_map()
    }
}

#[deprecated(since = "1.0.0", note = "Use the new property system instead")]
pub mod legacy {
    use super::*;
    
    pub fn create_node_with_string_props(id: &str, type_name: &str, 
                                         props: HashMap<String, String>,
                                         children: Vec<RenderNode>) -> RenderNode {
        RenderNode::from_legacy(
            id, 
            type_name, 
            props, 
            children, 
            Vec::new(), 
            NodeEventHandlers::default()
        )
    }
    
    pub fn get_prop_string(node: &RenderNode, key: &str) -> Option<String> {
        node.get_prop_as_string(key)
    }
```

## File: component.rs

```rs
// src/render/component.rs
use crate::UIComponent;
use crate::render::node::RenderNode;
use crate::components::registry::transform_component;

pub fn render(component: &UIComponent) -> RenderNode {
    transform_component(component)
}

pub mod event_helpers {
    use super::*;
    use crate::{events::EventType, render::node::EventHandler};

    pub fn create_event_handler(event_type: EventType, handler_id: &str) -> EventHandler {
        EventHandler {
            event_type,
            handler_id: handler_id.to_string(),
        }
    }
    
    pub fn add_common_event_handlers(
        node: &mut RenderNode,
        on_tap: Option<&str>,
        on_double_tap: Option<&str>,
        on_long_press: Option<&str>,
        on_hover_enter: Option<&str>,
        on_hover_exit: Option<&str>
    ) {
        if let Some(handler_id) = on_tap {
            node.on_tap(handler_id);
        }
        
        if let Some(handler_id) = on_double_tap {
            node.on_double_tap(handler_id);
        }
        
        if let Some(handler_id) = on_long_press {
            node.on_long_press(handler_id);
        }
        
        if let Some(handler_id) = on_hover_enter {
            node.on_hover_enter(handler_id);
        }
        
        if let Some(handler_id) = on_hover_exit {
            node.on_hover_exit(handler_id);
        }
    }
    
    pub fn add_touch_event_handlers(
        node: &mut RenderNode,
        on_touch_start: Option<&str>,
        on_touch_move: Option<&str>,
        on_touch_end: Option<&str>
    ) {
        if let Some(handler_id) = on_touch_start {
            node.on_event(EventType::TouchStart, handler_id);
        }
        
        if let Some(handler_id) = on_touch_move {
            node.on_event(EventType::TouchMove, handler_id);
        }
        
        if let Some(handler_id) = on_touch_end {
            node.on_event(EventType::TouchEnd, handler_id);
        }
    }
    
    pub fn add_swipe_event_handlers(
        node: &mut RenderNode,
        on_swipe_left: Option<&str>,
        on_swipe_right: Option<&str>,
        on_swipe_up: Option<&str>,
        on_swipe_down: Option<&str>
    ) {
        if let Some(handler_id) = on_swipe_left {
            node.on_swipe("left", handler_id);
        }
        
        if let Some(handler_id) = on_swipe_right {
            node.on_swipe("right", handler_id);
        }
        
        if let Some(handler_id) = on_swipe_up {
            node.on_swipe("up", handler_id);
        }
        
        if let Some(handler_id) = on_swipe_down {
            node.on_swipe("down", handler_id);
        }
    }
    
    pub fn add_focus_event_handlers(
        node: &mut RenderNode,
        on_focus: Option<&str>,
        on_blur: Option<&str>
    ) {
        if let Some(handler_id) = on_focus {
            node.on_event(EventType::Focus, handler_id);
        }
        
        if let Some(handler_id) = on_blur {
            node.on_event(EventType::Blur, handler_id);
        }
    }
    
    pub fn add_keyboard_event_handlers(
        node: &mut RenderNode,
        on_key_down: Option<&str>,
        on_key_up: Option<&str>
    ) {
        if let Some(handler_id) = on_key_down {
            node.on_event(EventType::KeyDown, handler_id);
        }
        
        if let Some(handler_id) = on_key_up {
            node.on_event(EventType::KeyUp, handler_id);
        }
    }
    
    pub fn add_value_event_handlers(
        node: &mut RenderNode,
        on_value_change: Option<&str>,
        on_submit: Option<&str>
    ) {
        if let Some(handler_id) = on_value_change {
            node.on_event(EventType::ValueChange, handler_id);
        }
        
        if let Some(handler_id) = on_submit {
            node.on_event(EventType::Submit, handler_id);
        }
    }
}

```

## File: event_middleware.rs

```rs
use std::sync::{
    Arc, 
    Mutex, 
    atomic::{AtomicBool, AtomicUsize, Ordering}
};
use std::time::{Duration, Instant};
use std::collections::{VecDeque, HashMap, HashSet};

use super::event_system::{Event, EventType};
use super::event_types::{EventError, EventSource};

#[derive(Debug, Clone, PartialEq)]
pub enum MiddlewareResult {
    Continue,
    Modified,
    Stop,
    Delay(Duration),
    Retry(usize),
}

#[derive(Debug, Clone)]
pub struct EventProcessingTrace {
    pub trace_id: String,
    pub timestamps: HashMap<String, Instant>,
    pub middleware_results: Vec<(String, MiddlewareResult)>,
    pub trace_data: HashMap<String, String>,
    pub error_count: usize,
}

impl EventProcessingTrace {
    pub fn new(trace_id: String) -> Self {
        Self {
            trace_id,
            timestamps: HashMap::new(),
            middleware_results: Vec::new(),
            trace_data: HashMap::new(),
            error_count: 0,
        }
    }
    
    pub fn mark_timestamp(&mut self, key: &str) {
        self.timestamps.insert(key.to_string(), Instant::now());
    }
    
    pub fn add_data(&mut self, key: &str, value: &str) {
        self.trace_data.insert(key.to_string(), value.to_string());
    }
    
    pub fn duration_between(&self, start_key: &str, end_key: &str) -> Option<Duration> {
        let start = self.timestamps.get(start_key)?;
        let end = self.timestamps.get(end_key)?;
        Some(end.duration_since(*start))
    }
    
    pub fn add_middleware_result(&mut self, middleware_name: &str, result: MiddlewareResult) {
        self.middleware_results.push((middleware_name.to_string(), result));
    }
    
    pub fn increment_error_count(&mut self) {
        self.error_count += 1;
    }
}

pub trait EventMiddleware: Send + Sync {
    fn process(&self, event: &mut Event) -> MiddlewareResult;
    
    fn name(&self) -> &'static str;
    
    fn cleanup(&mut self) -> Result<(), EventError> {
        Ok(())
    }
    
    fn initialize(&mut self) -> Result<(), EventError> {
        Ok(())
    }
}

pub struct EventMiddlewarePipeline {
    middlewares: Vec<Arc<Mutex<dyn EventMiddleware>>>,
    is_paused: AtomicBool,
    global_event_counter: AtomicUsize,
    timeout: Duration,
    max_retries: usize,
    trace_history: Mutex<VecDeque<EventProcessingTrace>>,
    max_trace_history: usize,
}

impl EventMiddlewarePipeline {
    pub fn new(timeout: Duration) -> Self {
        Self {
            middlewares: Vec::new(),
            is_paused: AtomicBool::new(false),
            global_event_counter: AtomicUsize::new(0),
            timeout,
            max_retries: 3,
            trace_history: Mutex::new(VecDeque::new()),
            max_trace_history: 100,
        }
    }
    
    pub fn with_max_retries(mut self, max_retries: usize) -> Self {
        self.max_retries = max_retries;
        self
    }
    
    pub fn with_max_trace_history(mut self, max_history: usize) -> Self {
        self.max_trace_history = max_history;
        self
    }
    
    pub fn add_middleware<M: EventMiddleware + 'static>(&mut self, mut middleware: M) -> Result<(), EventError> {
        middleware.initialize()?;
        self.middlewares.push(Arc::new(Mutex::new(middleware)));
        Ok(())
    }
    
    pub fn pause(&self) {
        self.is_paused.store(true, Ordering::SeqCst);
    }
    
    pub fn resume(&self) {
        self.is_paused.store(false, Ordering::SeqCst);
    }
    
    pub fn is_paused(&self) -> bool {
        self.is_paused.load(Ordering::SeqCst)
    }
    
    pub fn process(&self, event: &mut Event) -> Result<MiddlewareResult, EventError> {
        if self.is_paused() {
            return Err(EventError::ValidationError(
                "Middleware pipeline is currently paused".to_string()
            ));
        }
        
        let event_counter = self.global_event_counter.fetch_add(1, Ordering::SeqCst);
        
        let mut trace = EventProcessingTrace::new(format!("event_{}", event_counter));
        trace.mark_timestamp("start");
        trace.add_data("event_type", &format!("{:?}", event.event_type));
        
        let mut current_event = event.clone();
        let mut retry_count = 0;
        
        for middleware in &self.middlewares {
            if trace.timestamps.get("start").unwrap().elapsed() > self.timeout {
                trace.increment_error_count();
                trace.add_data("error", "Event processing exceeded global timeout");
                self.store_trace(trace);
                return Err(EventError::ValidationError(
                    "Event processing exceeded global timeout".to_string()
                ));
            }
            
            let middleware_name;
            let result;
            
            {
                let mut mw = middleware.lock().map_err(|_| {
                    trace.increment_error_count();
                    trace.add_data("error", "Failed to acquire middleware lock");
                    self.store_trace(trace.clone());
                    EventError::ValidationError("Failed to acquire middleware lock".to_string())
                })?;
                
                middleware_name = mw.name().to_string();
                trace.mark_timestamp(&format!("before_{}", middleware_name));
                
                result = mw.process(&mut current_event);
                
                trace.mark_timestamp(&format!("after_{}", middleware_name));
                trace.add_middleware_result(&middleware_name, result.clone());
            }
            
            match result {
                MiddlewareResult::Continue => continue,
                MiddlewareResult::Modified => continue,
                MiddlewareResult::Stop => {
                    trace.mark_timestamp("stop");
                    trace.add_data("stopped_by", &middleware_name);
                    self.store_trace(trace);
                    return Ok(MiddlewareResult::Stop);
                },
                MiddlewareResult::Delay(duration) => {
                    trace.add_data("delay", &format!("{:?}", duration));
                    std::thread::sleep(duration);
                },
                MiddlewareResult::Retry(suggested_retry) => {
                    retry_count += 1;
                    trace.add_data("retry_count", &retry_count.to_string());
                    
                    if retry_count > self.max_retries || retry_count > suggested_retry {
                        trace.increment_error_count();
                        trace.add_data("error", "Max retry attempts exceeded");
                        self.store_trace(trace);
                        return Err(EventError::ValidationError(
                            "Max retry attempts exceeded".to_string()
                        ));
                    }
                }
            }
        }
        
        trace.mark_timestamp("end");
        self.store_trace(trace);
        
        *event = current_event;
        
        Ok(MiddlewareResult::Continue)
    }
    
    fn store_trace(&self, trace: EventProcessingTrace) {
        let mut history = self.trace_history.lock().unwrap();
        history.push_back(trace);
        
        while history.len() > self.max_trace_history {
            history.pop_front();
        }
    }
    
    pub fn get_event_trace(&self, trace_id: &str) -> Option<EventProcessingTrace> {
        let history = self.trace_history.lock().unwrap();
        history.iter()
            .find(|trace| trace.trace_id == trace_id)
            .cloned()
    }
    
    pub fn clear_middlewares(&mut self) {
        for middleware in &self.middlewares {
            if let Ok(mut mw) = middleware.lock() {
                let _ = mw.cleanup();
            }
        }
        self.middlewares.clear();
    }
    
    pub fn middleware_names(&self) -> Vec<String> {
        self.middlewares.iter()
            .filter_map(|mw| {
                mw.lock().ok().map(|mw| mw.name().to_string())
            })
            .collect()
    }
}

pub mod middlewares {
    use super::*;
    
    pub struct LoggingMiddleware {
        log_level: LogLevel,
        custom_logger: Option<Box<dyn Fn(String) + Send + Sync>>,
        include_metadata: bool,
    }
    
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub enum LogLevel {
        Debug,
        Info,
        Warn,
        Error,
        Trace,
    }
    
    impl LoggingMiddleware {
        pub fn new(log_level: LogLevel) -> Self {
            Self { 
                log_level, 
                custom_logger: None,
                include_metadata: false,
            }
        }
        
        pub fn with_custom_logger(
            mut self, 
            logger: impl Fn(String) + Send + Sync + 'static
        ) -> Self {
            self.custom_logger = Some(Box::new(logger));
            self
        }
        
        pub fn with_metadata(mut self, include_metadata: bool) -> Self {
            self.include_metadata = include_metadata;
            self
        }
        
        fn log(&self, message: String) {
            if let Some(custom_logger) = &self.custom_logger {
                custom_logger(message);
            } else {
                match self.log_level {
                    LogLevel::Debug => println!("DEBUG: {}", message),
                    LogLevel::Info => println!("INFO: {}", message),
                    LogLevel::Warn => println!("WARN: {}", message),
                    LogLevel::Error => println!("ERROR: {}", message),
                    LogLevel::Trace => println!("TRACE: {}", message),
                }
            }
        }
    }
    
    impl EventMiddleware for LoggingMiddleware {
        fn process(&self, event: &mut Event) -> MiddlewareResult {
            match self.log_level {
                LogLevel::Debug => {
                    self.log(format!(
                        "Event Debug: {:?} at {:?} from {:?}", 
                        event.event_type, 
                        event.metadata.timestamp,
                        event.metadata.source
                    ));
                },
                LogLevel::Info => {
                    self.log(format!(
                        "Event Info: {:?} target:{:?}", 
                        event.event_type, 
                        event.target_id
                    ));
                },
                LogLevel::Trace => {
                    if self.include_metadata {
                        self.log(format!(
                            "Event Trace: Full Event {:?}, Metadata {:?}", 
                            event.event_type, 
                            event.metadata
                        ));
                    } else {
                        self.log(format!(
                            "Event Trace: {:?} at {:?}", 
                            event.event_type, 
                            event.timestamp
                        ));
                    }
                },
                _ => {}
            }
            
            MiddlewareResult::Continue
        }
        
        fn name(&self) -> &'static str {
            "LoggingMiddleware"
        }
    }
    
    pub struct RateLimitMiddleware {
        max_events_per_window: usize,
        window_duration: Duration,
        event_queue: Mutex<VecDeque<Instant>>,
        enforcement_mode: RateLimitMode,
        event_type_filters: Option<HashSet<EventType>>,
    }
    
    #[derive(Debug, Clone, Copy)]
    pub enum RateLimitMode {
        Drop,
        Queue,
        Delay,
        Throttle,
    }
    
    impl RateLimitMiddleware {
        pub fn new(
            max_events: usize, 
            window: Duration, 
            mode: RateLimitMode
        ) -> Self {
            Self {
                max_events_per_window: max_events,
                window_duration: window,
                event_queue: Mutex::new(VecDeque::new()),
                enforcement_mode: mode,
                event_type_filters: None,
            }
        }
        
        pub fn with_event_types(mut self, event_types: &[EventType]) -> Self {
            self.event_type_filters = Some(event_types.iter().cloned().collect());
            self
        }
    }
    
    impl EventMiddleware for RateLimitMiddleware {
        fn process(&self, event: &mut Event) -> MiddlewareResult {
            if let Some(filters) = &self.event_type_filters {
                if !filters.contains(&event.event_type) {
                    return MiddlewareResult::Continue;
                }
            }
            
            let now = Instant::now();
            let mut queue = self.event_queue.lock().unwrap();
            
            queue.retain(|&timestamp| now.duration_since(timestamp) <= self.window_duration);
            
            if queue.len() >= self.max_events_per_window {
                match self.enforcement_mode {
                    RateLimitMode::Drop => return MiddlewareResult::Stop,
                    RateLimitMode::Queue => {
                        return MiddlewareResult::Delay(Duration::from_millis(100));
                    },
                    RateLimitMode::Delay => {
                        return MiddlewareResult::Delay(
                            Duration::from_millis(50 * (queue.len() as u64))
                        );
                    },
                    RateLimitMode::Throttle => {
                        return MiddlewareResult::Retry(queue.len());
                    }
                }
            }
            
            queue.push_back(now);
            
            MiddlewareResult::Continue
        }
        
        fn name(&self) -> &'static str {
            "RateLimitMiddleware"
        }
    }
    
    pub struct FilterMiddleware {
        filters: Vec<Box<dyn Fn(&Event) -> bool + Send + Sync>>,
        rejection_logger: Option<Box<dyn Fn(&Event) + Send + Sync>>,
        rejection_reason: Mutex<Option<String>>,
    }
    
    impl FilterMiddleware {
        pub fn new() -> Self {
            Self {
                filters: Vec::new(),
                rejection_logger: None,
                rejection_reason: Mutex::new(None),
            }
        }
        
        pub fn add_filter<F>(mut self, filter: F) -> Self 
        where 
            F: Fn(&Event) -> bool + Send + Sync + 'static 
        {
            self.filters.push(Box::new(filter));
            self
        }
        
        pub fn with_rejection_logger(
            mut self, 
            logger: impl Fn(&Event) + Send + Sync + 'static
        ) -> Self {
            self.rejection_logger = Some(Box::new(logger));
            self
        }
        
        pub fn allow_sources(sources: &[EventSource]) -> Self {
            let sources_set: std::collections::HashSet<_> = sources.iter().cloned().collect();
            Self::new().add_filter(move |event| {
                sources_set.contains(&event.metadata.source)
            })
        }
        
        pub fn block_event_types(blocked_types: &[EventType]) -> Self {
            let blocked_set: std::collections::HashSet<_> = blocked_types.iter().cloned().collect();
            Self::new().add_filter(move |event| {
                !blocked_set.contains(&event.event_type)
            })
        }
        
        pub fn only_event_types(allowed_types: &[EventType]) -> Self {
            let allowed_set: std::collections::HashSet<_> = allowed_types.iter().cloned().collect();
            Self::new().add_filter(move |event| {
                allowed_set.contains(&event.event_type)
            })
        }
        
        pub fn get_last_rejection_reason(&self) -> Option<String> {
            self.rejection_reason.lock().unwrap().clone()
        }
    }
    
    impl EventMiddleware for FilterMiddleware {
        fn process(&self, event: &mut Event) -> MiddlewareResult {
            for (i, filter) in self.filters.iter().enumerate() {
                if !filter(event) {
                    let reason = format!("Rejected by filter {}", i);
                    *self.rejection_reason.lock().unwrap() = Some(reason);
                    
                    if let Some(logger) = &self.rejection_logger {
                        logger(event);
                    }
                    return MiddlewareResult::Stop;
                }
            }
            
            *self.rejection_reason.lock().unwrap() = None;
            MiddlewareResult::Continue
        }
        
        fn name(&self) -> &'static str {
            "FilterMiddleware"
        }
    }
    
    pub struct EventTransformerMiddleware {
        transformers: Vec<Box<dyn Fn(&mut Event) -> bool + Send + Sync>>,
    }
    
    impl EventTransformerMiddleware {
        pub fn new() -> Self {
            Self {
                transformers: Vec::new(),
            }
        }
        
        pub fn add_transformer<F>(mut self, transformer: F) -> Self 
        where 
            F: Fn(&mut Event) -> bool + Send + Sync + 'static 
        {
            self.transformers.push(Box::new(transformer));
            self
        }
    }
    
    impl EventMiddleware for EventTransformerMiddleware {
        fn process(&self, event: &mut Event) -> MiddlewareResult {
            let mut modified = false;
            
            for transformer in &self.transformers {
                if transformer(event) {
                    modified = true;
                }
            }
            
            if modified {
                MiddlewareResult::Modified
            } else {
                MiddlewareResult::Continue
            }
        }
        
        fn name(&self) -> &'static str {
            "EventTransformerMiddleware"
        }
    }
    
    pub struct EventDebugMiddleware {
        enabled: AtomicBool,
        debug_log: Arc<Mutex<Vec<String>>>,
        max_logs: usize,
    }
    
    impl EventDebugMiddleware {
        pub fn new(max_logs: usize) -> Self {
            Self {
                enabled: AtomicBool::new(true),
                debug_log: Arc::new(Mutex::new(Vec::new())),
                max_logs,
            }
        }
        
        pub fn enable(&self) {
            self.enabled.store(true, Ordering::SeqCst);
        }
        
        pub fn disable(&self) {
            self.enabled.store(false, Ordering::SeqCst);
        }
        
        pub fn is_enabled(&self) -> bool {
            self.enabled.load(Ordering::SeqCst)
        }
        
        pub fn get_logs(&self) -> Vec<String> {
            self.debug_log.lock().unwrap().clone()
        }
        
        pub fn clear_logs(&self) {
            self.debug_log.lock().unwrap().clear();
        }
        
        fn add_log(&self, message: String) {
            let mut logs = self.debug_log.lock().unwrap();
            logs.push(message);
            
            while logs.len() > self.max_logs {
                logs.remove(0);
            }
        }
    }
    
    impl EventMiddleware for EventDebugMiddleware {
        fn process(&self, event: &mut Event) -> MiddlewareResult {
            if self.is_enabled() {
                let log_entry = format!(
                    "[{}] {:?} from {:?} with target {:?}", 
                    event.id,
                    event.event_type,
                    event.metadata.source,
                    event.target_id
                );
                
                self.add_log(log_entry);
            }
            
            MiddlewareResult::Continue
        }
        
        fn name(&self) -> &'static str {
            "EventDebugMiddleware"
        }
    }
```

## File: layout_engine.rs

```rs
use std::collections::HashMap;
use crate::extract_base_props;
use crate::render::node::RenderNode;
use crate::shared::properties::PropertyBag;
use crate::layout::types::{Rect, Size};
use crate::layout::layout_info::LayoutInfo;
use crate::render::property::Property;

use super::stack_layout::{measure_hstack, measure_vstack, position_hstack_children, position_vstack_children};
use super::zstack_layout::{measure_zstack, position_zstack_children};
use super::text_layout::measure_text;
use super::button_layout::measure_button;
use super::image_layout::measure_image;
use super::scroll_layout::{measure_scroll, position_scroll_children};
use super::spacer_layout::measure_spacer;
use super::divider_layout::measure_divider;

pub trait LayoutMeasurement {
    fn measure_node(&mut self, node: &RenderNode, available_size: Size) -> Size;
    fn get_layout_cache(&mut self) -> &mut HashMap<String, LayoutInfo>;
}

pub trait LayoutPositioning {
    fn position_node(&mut self, node: &RenderNode, frame: Rect);
    fn get_layout_cache(&mut self) -> &mut HashMap<String, LayoutInfo>;
}

pub struct LayoutEngine {
    layout_cache: HashMap<String, LayoutInfo>,
}

impl LayoutEngine {
    pub fn new() -> Self {
        Self {
            layout_cache: HashMap::new(),
        }
    }

    pub fn compute_layout<'a>(&mut self, node: &'a mut RenderNode, container_size: Size) -> &'a mut RenderNode {
        self.layout_cache.clear();
        
        self.measure_node(node, container_size);
        
        self.position_node(node, Rect::from_size(container_size.width, container_size.height));
        
        self.apply_layout(node);
        
        node
    }

    pub fn compute_enhanced_layout<'a>(&mut self, node: &'a mut RenderNode, container_size: Size) -> &'a mut RenderNode {
        self.layout_cache.clear();
        
        self.measure_node(node, container_size);
        self.position_node(node, Rect::from_size(container_size.width, container_size.height));
        self.apply_layout_with_clipping(node);
        
        node
    }

    fn measure_node(&mut self, node: &RenderNode, available_size: Size) -> Size {
        let node_type = &node.type_name;
        
        let content_size = match node_type.as_str() {
            "VStack" => measure_vstack(node, available_size, self),
            "HStack" => measure_hstack(node, available_size, self),
            "ZStack" => measure_zstack(node, available_size, self),
            "Text" => measure_text(node, available_size),
            "Button" => measure_button(node, available_size),
            "Image" => measure_image(node, available_size),
            "Scroll" => measure_scroll(node, available_size, self),
            "Spacer" => measure_spacer(node, available_size),
            "Divider" => measure_divider(node, available_size),
            _ => Size::zero(),
        };
        
        let mut layout_info = LayoutInfo::new().with_content_size(content_size);
        
        self.apply_base_layout_properties(node, &mut layout_info);
        
        self.layout_cache.insert(node.id.clone(), layout_info);
        
        content_size
    }

    fn apply_base_layout_properties(&self, node: &RenderNode, layout_info: &mut LayoutInfo) {
        let base_props = node.properties.get("base_props")
        .and_then(|prop| prop.as_map())
        .map(|map| {
            let string_map: HashMap<String, String> = map.iter()
                .map(|(k, v)| (k.clone(), v.to_string_value()))
                .collect();
            
            extract_base_props(&PropertyBag::from_string_map(&string_map))
        });
        
        if let Some(props) = base_props {
            if let Some(width) = props.width { layout_info.content_size.width = width; }
            if let Some(height) = props.height { layout_info.content_size.height = height; }
            
            if let Some(min_width) = props.min_width { layout_info.min_width = Some(min_width); }
            if let Some(max_width) = props.max_width { layout_info.max_width = Some(max_width); }
            if let Some(min_height) = props.min_height { layout_info.min_height = Some(min_height); }
            if let Some(max_height) = props.max_height { layout_info.max_height = Some(max_height); }
            
            if let Some(padding) = props.padding { layout_info.padding = Some(padding); }
            
            if let Some(edge_insets) = props.edge_insets {
                layout_info.content_size.width -= edge_insets.horizontal_insets();
                layout_info.content_size.height -= edge_insets.vertical_insets();
            }
        }
    }

    fn position_node(&mut self, node: &RenderNode, frame: Rect) {
        let inner_frame = {
            if let Some(layout_info) = self.layout_cache.get_mut(&node.id) {
                layout_info.frame = frame;
                
                if let Some(padding) = layout_info.padding {
                    frame.inset(padding)
                } else {
                    frame
                }
            } else {
                return;
            }
        };
        
        match node.type_name.as_str() {
            "VStack" => position_vstack_children(node, inner_frame, self),
            "HStack" => position_hstack_children(node, inner_frame, self),
            "ZStack" => position_zstack_children(node, inner_frame, self),
            "Scroll" => position_scroll_children(node, inner_frame, self),
            _ => (),
        }
    }

    fn apply_layout(&self, node: &mut RenderNode) {
        if let Some(layout) = self.layout_cache.get(&node.id) {
            node.properties.set("x", layout.frame.x);
            node.properties.set("y", layout.frame.y);
            node.properties.set("width", layout.frame.width);
            node.properties.set("height", layout.frame.height);
            
            for child in &mut node.children {
                self.apply_layout(child);
            }
        }
    }

    fn apply_layout_with_clipping(&self, node: &mut RenderNode) {
        if let Some(layout) = self.layout_cache.get(&node.id) {
            node.properties.set("x", layout.frame.x);
            node.properties.set("y", layout.frame.y);
            node.properties.set("width", layout.frame.width);
            node.properties.set("height", layout.frame.height);
            
            if let Some(Property::Boolean(true)) = node.properties.get("clip_to_bounds") {
                node.properties.set("clip_to_bounds", true);
            }
            
            for child in &mut node.children {
                self.apply_layout_with_clipping(child);
            }
        }
    }
}

impl LayoutMeasurement for LayoutEngine {
    fn measure_node(&mut self, node: &RenderNode, available_size: Size) -> Size {
        self.measure_node(node, available_size)
    }
    
    fn get_layout_cache(&mut self) -> &mut HashMap<String, LayoutInfo> {
        &mut self.layout_cache
    }
}

impl LayoutPositioning for LayoutEngine {
    fn position_node(&mut self, node: &RenderNode, frame: Rect) {
        self.position_node(node, frame)
    }
    
    fn get_layout_cache(&mut self) -> &mut HashMap<String, LayoutInfo> {
        &mut self.layout_cache
    }
```

## File: gesture_recognition.rs

```rs
use std::time::{Duration, Instant};
use std::collections::{VecDeque, HashMap};
use std::sync::atomic::{AtomicUsize, Ordering};

use super::event_system::{Event, EventType, EventPayload, SwipeDirection};

#[derive(Clone)]
pub struct GestureRecognitionConfig {
    pub tap_max_duration: Duration,
    pub tap_max_distance: f32,
    pub double_tap_max_interval: Duration,
    
    pub swipe_min_distance: f32,
    pub swipe_max_duration: Duration,
    pub swipe_min_velocity: f32,
    pub multi_swipe_cooldown: Duration,
    
    pub long_press_min_duration: Duration,
    pub long_press_max_distance: f32,
    
    pub pinch_min_scale_change: f32,
    pub rotate_min_angle: f32,
}

impl Default for GestureRecognitionConfig {
    fn default() -> Self {
        Self {
            tap_max_duration: Duration::from_millis(250),
            tap_max_distance: 10.0,
            double_tap_max_interval: Duration::from_millis(300),
            
            swipe_min_distance: 50.0,
            swipe_max_duration: Duration::from_millis(500),
            swipe_min_velocity: 0.5,
            multi_swipe_cooldown: Duration::from_millis(200),
            
            long_press_min_duration: Duration::from_millis(500),
            long_press_max_distance: 20.0,
            
            pinch_min_scale_change: 0.1,
            rotate_min_angle: 15.0,
        }
    }
}

#[derive(Clone, Debug)]
pub struct GesturePayload {
    pub start_position: (f32, f32),
    pub end_position: (f32, f32),
    pub duration: Duration,
    pub velocity: f32,
    pub additional_details: HashMap<String, String>,
}

impl EventPayload for GesturePayload {
    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
    
    fn clone_box(&self) -> Box<dyn EventPayload> {
        Box::new(self.clone())
    }
}

pub struct GestureRecognizer {
    config: GestureRecognitionConfig,
    touch_history: VecDeque<(Instant, Event)>,
    max_history_size: usize,
    tap_count: AtomicUsize,
    last_tap_time: Option<Instant>,
    multi_swipe_tracker: HashMap<SwipeDirection, Instant>,
}

impl GestureRecognizer {
    pub fn new(config: Option<GestureRecognitionConfig>) -> Self {
        Self {
            config: config.unwrap_or_default(),
            touch_history: VecDeque::new(),
            max_history_size: 20,
            tap_count: AtomicUsize::new(0),
            last_tap_time: None,
            multi_swipe_tracker: HashMap::new(),
        }
    }
    
    pub fn process_event(&mut self, event: Event) -> Option<Event> {
        self.update_touch_history(event.clone());
        
        match event.event_type {
            EventType::TouchStart => self.handle_touch_start(event),
            EventType::TouchMove => self.handle_touch_move(event),
            EventType::TouchEnd => self.handle_touch_end(event),
            _ => None
        }
    }
    
    fn update_touch_history(&mut self, event: Event) {
        let now = Instant::now();
        self.touch_history.push_back((now, event));
        
        while self.touch_history.len() > self.max_history_size {
            self.touch_history.pop_front();
        }
    }
    
    fn handle_touch_start(&mut self, event: Event) -> Option<Event> {
        None
    }
    
    fn handle_touch_move(&mut self, event: Event) -> Option<Event> {
        None
    }
    
    fn handle_touch_end(&mut self, event: Event) -> Option<Event> {
        if let Some(tap_event) = self.detect_tap() {
            return Some(tap_event);
        }
        
        if let Some(long_press_event) = self.detect_long_press() {
            return Some(long_press_event);
        }
        
        if let Some(swipe_event) = self.detect_swipe() {
            return Some(swipe_event);
        }
        
        None
    }
    
    pub fn detect_tap(&mut self) -> Option<Event> {
        if self.touch_history.len() < 2 {
            return None;
        }
        
        let (start_time, start_event) = &self.touch_history[0];
        let (end_time, end_event) = self.touch_history.back()?;
        
        let duration = end_time.duration_since(*start_time);
        let start_pos = start_event.position?;
        let end_pos = end_event.position?;
        
        let distance = ((start_pos.0 - end_pos.0).powi(2) + (start_pos.1 - end_pos.1).powi(2)).sqrt();
        
        if duration <= self.config.tap_max_duration && distance <= self.config.tap_max_distance {
            let current_time = Instant::now();
            let tap_count = self.tap_count.fetch_add(1, Ordering::SeqCst) + 1;
            
            let event_type = if tap_count > 1 && 
               self.last_tap_time.map_or(false, |last| 
                   current_time.duration_since(last) <= self.config.double_tap_max_interval
               ) {
                EventType::DoubleTap
            } else {
                EventType::Tap
            };
            
            self.last_tap_time = Some(current_time);
            
            let mut tap_event = Event::new(event_type, end_event.metadata.source.clone())
                .with_position(end_pos.0, end_pos.1);
                
            let gesture_payload = GesturePayload {
                start_position: start_pos,
                end_position: end_pos,
                duration,
                velocity: 0.0,
                additional_details: HashMap::from([
                    ("tap_count".to_string(), tap_count.to_string())
                ]),
            };
            
            tap_event = tap_event.with_payload(gesture_payload);
            
            if let Some(target_id) = &end_event.target_id {
                tap_event = tap_event.with_target(target_id.clone());
            }
            
            return Some(tap_event);
        }
        
        None
    }
    
    fn detect_long_press(&self) -> Option<Event> {
        if self.touch_history.len() < 2 {
            return None;
        }
        
        let (start_time, start_event) = &self.touch_history[0];
        let (end_time, end_event) = self.touch_history.back()?;
        
        let duration = end_time.duration_since(*start_time);
        let start_pos = start_event.position?;
        let end_pos = end_event.position?;
        
        let distance = ((start_pos.0 - end_pos.0).powi(2) + (start_pos.1 - end_pos.1).powi(2)).sqrt();
        
        if duration >= self.config.long_press_min_duration && 
           distance <= self.config.long_press_max_distance {
            
            let mut long_press_event = Event::new(
                EventType::LongPress, 
                end_event.metadata.source.clone()
            )
            .with_position(end_pos.0, end_pos.1);
            
            let gesture_payload = GesturePayload {
                start_position: start_pos,
                end_position: end_pos,
                duration,
                velocity: 0.0,
                additional_details: HashMap::from([
                    ("press_duration_ms".to_string(), duration.as_millis().to_string())
                ]),
            };
            
            long_press_event = long_press_event.with_payload(gesture_payload);
            
            if let Some(target_id) = &end_event.target_id {
                long_press_event = long_press_event.with_target(target_id.clone());
            }
            
            return Some(long_press_event);
        }
        
        None
    }
    
    fn detect_swipe(&mut self) -> Option<Event> {
        if self.touch_history.len() < 2 {
            return None;
        }
        
        let (start_time, start_event) = &self.touch_history[0];
        let (end_time, end_event) = self.touch_history.back()?;
        
        let duration = end_time.duration_since(*start_time);
        let start_pos = start_event.position?;
        let end_pos = end_event.position?;
        
        let dx = end_pos.0 - start_pos.0;
        let dy = end_pos.1 - start_pos.1;
        let distance = (dx.powi(2) + dy.powi(2)).sqrt();
        let velocity = distance / duration.as_secs_f32();
        
        if duration <= self.config.swipe_max_duration && 
           distance >= self.config.swipe_min_distance && 
           velocity >= self.config.swipe_min_velocity {
            
            let direction = if dx.abs() > dy.abs() {
                if dx > 0.0 { SwipeDirection::Right } else { SwipeDirection::Left }
            } else {
                if dy > 0.0 { SwipeDirection::Down } else { SwipeDirection::Up }
            };
            
            let now = Instant::now();
            
            let is_multi_swipe = match self.multi_swipe_tracker.get(&direction) {
                Some(last_swipe_time) => now.duration_since(*last_swipe_time) <= self.config.multi_swipe_cooldown,
                None => false
            };
            
            self.multi_swipe_tracker.insert(direction.clone(), now);
            
            let mut swipe_event = Event::new(
                EventType::Swipe(direction),
                end_event.metadata.source.clone()
            )
            .with_position(end_pos.0, end_pos.1);
            
            let gesture_payload = GesturePayload {
                start_position: start_pos,
                end_position: end_pos,
                duration,
                velocity,
                additional_details: HashMap::from([
                    ("is_multi_swipe".to_string(), is_multi_swipe.to_string())
                ]),
            };
            
            swipe_event = swipe_event.with_payload(gesture_payload);
            
            if let Some(target_id) = &end_event.target_id {
                swipe_event = swipe_event.with_target(target_id.clone());
            }
            
            return Some(swipe_event);
        }
        
        None
    }
```

## File: styles.rs

```rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct GradientStop {
    pub color: String,
    pub position: f32,
    pub name: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum GradientType {
    Linear,
    Radial,
    Conic,
    Repeating,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct Gradient {
    pub stops: Vec<GradientStop>,
    pub start_point: (f32, f32),
    pub end_point: (f32, f32),
    pub gradient_type: GradientType,
    
    pub angle: Option<f32>,
    pub spread_method: Option<SpreadMethod>,
    
    pub name: Option<String>,
    pub custom_props: Option<HashMap<String, String>>,
    
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum SpreadMethod {
    Pad,
    Reflect,
    Repeat,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct ShadowEffect {
    pub color: String,
    pub offset: (f32, f32),
    pub blur_radius: f32,
    
    pub spread_radius: Option<f32>,
    pub inset: Option<bool>,
    pub opacity: Option<f32>,
    
    pub name: Option<String>,
    pub z_index: Option<i32>,
}

impl Gradient {
    pub fn linear(stops: Vec<GradientStop>, start: (f32, f32), end: (f32, f32)) -> Self {
        Self {
            stops,
            start_point: start,
            end_point: end,
            gradient_type: GradientType::Linear,
            angle: None,
            spread_method: None,
            name: None,
            custom_props: None,
        }
    }
    
    pub fn radial(stops: Vec<GradientStop>, center: (f32, f32), radius: f32) -> Self {
        Self {
            stops,
            start_point: center,
            end_point: (center.0 + radius, center.1 + radius),
            gradient_type: GradientType::Radial,
            angle: None,
            spread_method: None,
            name: None,
            custom_props: None,
        }
    }
    
    pub fn with_custom_prop(mut self, key: &str, value: &str) -> Self {
        let mut props = self.custom_props.take().unwrap_or_default();
        props.insert(key.to_string(), value.to_string());
        self.custom_props = Some(props);
        self
    }
    
    pub fn with_name(mut self, name: &str) -> Self {
        self.name = Some(name.to_string());
        self
    }
}

impl ShadowEffect {
    pub fn new(color: &str, offset: (f32, f32), blur_radius: f32) -> Self {
        Self {
            color: color.to_string(),
            offset,
            blur_radius,
            spread_radius: None,
            inset: None,
            opacity: None,
            name: None,
            z_index: None,
        }
    }
    
    pub fn with_spread(mut self, spread_radius: f32) -> Self {
        self.spread_radius = Some(spread_radius);
        self
    }
    
    pub fn inset(mut self) -> Self {
        self.inset = Some(true);
        self
    }
    
    pub fn with_opacity(mut self, opacity: f32) -> Self {
        self.opacity = Some(opacity.max(0.0).min(1.0));
        self
    }
    
    pub fn with_name(mut self, name: &str) -> Self {
        self.name = Some(name.to_string());
        self
    }
    
    pub fn with_z_index(mut self, z_index: i32) -> Self {
        self.z_index = Some(z_index);
        self
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum BorderStyle {
    Solid,
    Dashed,
    Dotted,
    None,
}

impl Default for BorderStyle {
    fn default() -> Self {
        BorderStyle::Solid
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum TextTransform {
    None,
    Uppercase,
    Lowercase,
    Capitalize,
}

impl Default for TextTransform {
    fn default() -> Self {
        TextTransform::None
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum TextAlign {
    Left,
    Center,
    Right,
}

impl Default for TextAlign {
    fn default() -> Self {
        TextAlign::Center
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum Overflow {
    Visible,
    Hidden,
    Scroll,
    Ellipsis,
}

impl Default for Overflow {
    fn default() -> Self {
        Overflow::Visible
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum LoadingIndicatorType {
    Spinner,
    DotPulse,
    BarPulse,
    Custom,
}

impl Default for LoadingIndicatorType {
    fn default() -> Self {
        LoadingIndicatorType::Spinner
    }
```

## File: shared.rs

```rs
use crate::render::renderer::DrawingContext;
use crate::render::node::RenderNode;
use crate::layout::Rect;
use crate::{Color, Gradient, GradientType};
use std::f32::consts::PI;

pub fn parse_color(color: &str) -> String {
    Color::from_hex(color).to_css_string()
}

fn is_named_color(color: &str) -> bool {
    const NAMED_COLORS: [&str; 148] = [
        "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", 
        "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", 
        "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", 
        "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", 
        "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", 
        "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", 
        "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", 
        "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", 
        "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", 
        "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", 
        "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", 
        "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", 
        "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", 
        "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", 
        "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", 
        "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", 
        "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", 
        "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", 
        "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", 
        "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", 
        "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", 
        "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", 
        "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", 
        "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", 
        "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", 
        "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", 
        "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", 
        "whitesmoke", "yellowgreen", "transparent"
    ];

    NAMED_COLORS.contains(&color.to_lowercase().as_str())
}

pub fn draw_rounded_rect<T: DrawingContext>(
    context: &T, 
    x: f32, 
    y: f32, 
    width: f32, 
    height: f32, 
    radius: f32
) -> Result<(), String> {
    if radius <= 0.0 {
        context.rect(x, y, width, height)?;
        return Ok(());
    }
    
    let radius = radius.min(width / 2.0).min(height / 2.0);
    
    context.begin_path()?;
    
    context.move_to(x + radius, y)?;
    
    context.line_to(x + width - radius, y)?;
    context.arc(x + width - radius, y + radius, radius, -0.5 * PI, 0.0, false)?;
    
    context.line_to(x + width, y + height - radius)?;
    context.arc(x + width - radius, y + height - radius, radius, 0.0, 0.5 * PI, false)?;
    
    context.line_to(x + radius, y + height)?;
    context.arc(x + radius, y + height - radius, radius, 0.5 * PI, PI, false)?;
    
    context.line_to(x, y + radius)?;
    context.arc(x + radius, y + radius, radius, PI, 1.5 * PI, false)?;
    
    context.close_path()?;
    
    Ok(())
}

pub fn draw_background<T: DrawingContext>(
    context: &T, 
    node: &RenderNode, 
    frame: Rect
) -> Result<(), String> {
    if let Some(bg_color) = node.get_prop("background") {
        context.set_fill_color(&parse_color(&bg_color))?;
        context.begin_path()?;
        draw_rounded_rect(
            context, 
            frame.x, 
            frame.y, 
            frame.width, 
            frame.height, 
            node.get_prop_f32("border_radius").unwrap_or(0.0)
        )?;
        context.fill()?;
    }
    
    Ok(())
}

pub fn draw_border<T: DrawingContext>(
    context: &T, 
    node: &RenderNode, 
    frame: Rect
) -> Result<(), String> {
    if let Some(border_width) = node.get_prop_f32("border_width") {
        if border_width > 0.0 {
            let border_color = node.get_prop("border_color")
                .map(|c| parse_color(c))
                .unwrap_or_else(|| "#000000".to_string());
            
            let border_radius = node.get_prop_f32("border_radius").unwrap_or(0.0);
            
            context.begin_path()?;
            draw_rounded_rect(
                context, 
                frame.x, 
                frame.y, 
                frame.width, 
                frame.height, 
                border_radius
            )?;
            
            context.set_stroke_color(&border_color)?;
            context.set_line_width(border_width)?;
            context.stroke()?;
        }
    }
    
    Ok(())
}

pub fn apply_shadow<T: DrawingContext>(
    context: &T,
    shadow_color: Option<&str>,
    shadow_offset_x: Option<f32>,
    shadow_offset_y: Option<f32>,
    shadow_blur: Option<f32>
) -> Result<bool, String> {
    if let (Some(color), Some(blur)) = (shadow_color, shadow_blur) {
        if blur > 0.0 {
            let offset_x = shadow_offset_x.unwrap_or(0.0);
            let offset_y = shadow_offset_y.unwrap_or(0.0);
            context.set_shadow(offset_x, offset_y, blur, &parse_color(color))?;
            return Ok(true);
        }
    }
    
    Ok(false)
}

pub fn clear_shadow<T: DrawingContext>(
    context: &T,
    shadow_applied: bool
) -> Result<(), String> {
    if shadow_applied {
        context.clear_shadow()?;
    }
    
    Ok(())
}

pub fn create_gradient<T: DrawingContext>(
    context: &T,
    node: &RenderNode,
    frame: Rect
) -> Result<Option<String>, String> {
    let gradient_type = node.get_prop("gradient_type");
    let gradient_color_count = node.get_prop_f32("gradient_color_count")
        .unwrap_or(0.0) as usize;
    
    if gradient_color_count == 0 {
        return Ok(None);
    }
    
    let mut color_stops = Vec::new();
    for i in 0..gradient_color_count {
        let color = node.get_prop(&format!("gradient_color_{}", i))
            .map(|c| parse_color(c))
            .unwrap_or_else(|| "#000000".to_string());
        
        let position = node.get_prop_f32(&format!("gradient_position_{}", i))
            .unwrap_or((i as f32) / ((gradient_color_count - 1) as f32));
        
        color_stops.push((position, color));
    }
    
    let start_x = node.get_prop_f32("gradient_start_x").unwrap_or(0.0);
    let start_y = node.get_prop_f32("gradient_start_y").unwrap_or(0.0);
    let end_x = node.get_prop_f32("gradient_end_x").unwrap_or(1.0);
    let end_y = node.get_prop_f32("gradient_end_y").unwrap_or(1.0);
    
    let gradient_id = if gradient_type.map(|t| t == "radial").unwrap_or(false) {
        let center_x = frame.x + frame.width * start_x;
        let center_y = frame.y + frame.height * start_y;
        let radius = ((frame.width * frame.width + frame.height * frame.height) as f32).sqrt() / 2.0;
        
        context.create_radial_gradient(
            center_x, 
            center_y, 
            0.0,
            center_x, 
            center_y, 
            radius,
            color_stops
        )?
    } else {
        context.create_linear_gradient(
            frame.x + frame.width * start_x,
            frame.y + frame.height * start_y,
            frame.x + frame.width * end_x,
            frame.y + frame.height * end_y,
            color_stops
        )?
    };
    
    Ok(Some(gradient_id))
}


pub fn apply_background<T: DrawingContext>(
    context: &T,
    gradient: Option<&Gradient>,
    background_color: Option<&str>,
    frame_x: f32,
    frame_y: f32,
    frame_width: f32,
    frame_height: f32
) -> Result<(), String> {
    if let Some(gradient_def) = gradient {
        let gradient_id = match gradient_def.gradient_type {
            GradientType::Radial => {
                let center_x = frame_x + frame_width / 2.0;
                let center_y = frame_y + frame_height / 2.0;
                let radius = (frame_width.powi(2) + frame_height.powi(2)).sqrt() / 2.0;
                let color_stops: Vec<(f32, String)> = gradient_def.stops
                            .iter()
                            .map(|stop| (stop.position, parse_color(&stop.color)))
                            .collect();
                context.create_radial_gradient(
                            center_x,
                            center_y,
                            0.0,
                            center_x,
                            center_y,
                            radius,
                            color_stops
                        )?
            }
            _ => {
                    let (start_x, start_y) = (
                        frame_x + gradient_def.start_point.0 * frame_width,
                        frame_y + gradient_def.start_point.1 * frame_height
                    );
            
                    let (end_x, end_y) = (
                        frame_x + gradient_def.end_point.0 * frame_width,
                        frame_y + gradient_def.end_point.1 * frame_height
                    );
            
                    let color_stops: Vec<(f32, String)> = gradient_def.stops
                        .iter()
                        .map(|stop| (stop.position, parse_color(&stop.color)))
                        .collect();
            
                    context.create_linear_gradient(
                        start_x,
                        start_y,
                        end_x,
                        end_y,
                        color_stops
                    )?
                }
        };
        
        context.set_fill_gradient(&gradient_id)?;
    } else if let Some(color) = background_color {
        context.set_fill_color(&parse_color(color))?;
    } else {
        context.set_fill_color("#000000")?;
    }
    
    Ok(())
```
