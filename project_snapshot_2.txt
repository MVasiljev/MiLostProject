function _fd_close(fd) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.close(stream);
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

/** @param {number=} offset */
var doReadv = (stream, iov, iovcnt, offset) => {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
    var ptr = HEAPU32[iov >> 2];
    var len = HEAPU32[(iov + 4) >> 2];
    iov += 8;
    var curr = FS.read(stream, HEAP8, ptr, len, offset);
    if (curr < 0) return -1;
    ret += curr;
    if (curr < len) break; // nothing more to read
    if (typeof offset != "undefined") {
      offset += curr;
    }
  }
  return ret;
};

function _fd_read(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = doReadv(stream, iov, iovcnt);
    HEAPU32[pnum >> 2] = num;
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  var offset = convertI32PairToI53Checked(offset_low, offset_high);

  try {
    if (isNaN(offset)) return 61;
    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.llseek(stream, offset, whence);
    (tempI64 = [
      stream.position >>> 0,
      ((tempDouble = stream.position),
      +Math.abs(tempDouble) >= 1.0
        ? tempDouble > 0.0
          ? +Math.floor(tempDouble / 4294967296.0) >>> 0
          : ~~+Math.ceil(
              (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0
            ) >>> 0
        : 0),
    ]),
      (HEAP32[newOffset >> 2] = tempI64[0]),
      (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

/** @param {number=} offset */
var doWritev = (stream, iov, iovcnt, offset) => {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
    var ptr = HEAPU32[iov >> 2];
    var len = HEAPU32[(iov + 4) >> 2];
    iov += 8;
    var curr = FS.write(stream, HEAP8, ptr, len, offset);
    if (curr < 0) return -1;
    ret += curr;
    if (curr < len) {
      // No more space to write.
      break;
    }
    if (typeof offset != "undefined") {
      offset += curr;
    }
  }
  return ret;
};

function _fd_write(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = doWritev(stream, iov, iovcnt);
    HEAPU32[pnum >> 2] = num;
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

function _random_get(buffer, size) {
  try {
    randomFill(HEAPU8.subarray(buffer, buffer + size));
    return 0;
  } catch (e) {
    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
    return e.errno;
  }
}

var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
var stringToUTF8OnStack = (str) => {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8(str, ret, size);
  return ret;
};

var WebGPU = {
  errorCallback: (callback, type, message, userdata) => {
    var sp = stackSave();
    var messagePtr = stringToUTF8OnStack(message);
    ((a1, a2, a3) => dynCall_viii(callback, a1, a2, a3))(
      type,
      messagePtr,
      userdata
    );
    stackRestore(sp);
  },
  initManagers: () => {
    assert(!WebGPU.mgrDevice, "initManagers already called");

    /** @constructor */
    function Manager() {
      this.objects = {};
      this.nextId = 1;
      this.create = function (object, wrapper = {}) {
        var id = this.nextId++;
        assert(typeof this.objects[id] == "undefined");
        wrapper.refcount = 1;
        wrapper.object = object;
        this.objects[id] = wrapper;
        return id;
      };
      this.get = function (id) {
        if (!id) return undefined;
        var o = this.objects[id];
        assert(typeof o != "undefined");
        return o.object;
      };
      this.reference = function (id) {
        var o = this.objects[id];
        assert(typeof o != "undefined");
        o.refcount++;
      };
      this.release = function (id) {
        var o = this.objects[id];
        assert(typeof o != "undefined");
        assert(o.refcount > 0);
        o.refcount--;
        if (o.refcount <= 0) {
          delete this.objects[id];
        }
      };
    }

    WebGPU.mgrSurface = new Manager();
    WebGPU.mgrSwapChain = new Manager();

    WebGPU.mgrAdapter = new Manager();
    // TODO: Release() the device's default queue when the device is freed.
    WebGPU.mgrDevice = new Manager();
    WebGPU.mgrQueue = new Manager();

    WebGPU.mgrCommandBuffer = new Manager();
    WebGPU.mgrCommandEncoder = new Manager();
    WebGPU.mgrRenderPassEncoder = new Manager();
    WebGPU.mgrComputePassEncoder = new Manager();

    WebGPU.mgrBindGroup = new Manager();
    WebGPU.mgrBuffer = new Manager();
    WebGPU.mgrSampler = new Manager();
    WebGPU.mgrTexture = new Manager();
    WebGPU.mgrTextureView = new Manager();
    WebGPU.mgrQuerySet = new Manager();

    WebGPU.mgrBindGroupLayout = new Manager();
    WebGPU.mgrPipelineLayout = new Manager();
    WebGPU.mgrRenderPipeline = new Manager();
    WebGPU.mgrComputePipeline = new Manager();
    WebGPU.mgrShaderModule = new Manager();

    WebGPU.mgrRenderBundleEncoder = new Manager();
    WebGPU.mgrRenderBundle = new Manager();
  },
  makeColor: (ptr) => {
    return {
      r: HEAPF64[ptr >> 3],
      g: HEAPF64[(ptr + 8) >> 3],
      b: HEAPF64[(ptr + 16) >> 3],
      a: HEAPF64[(ptr + 24) >> 3],
    };
  },
  makeExtent3D: (ptr) => {
    return {
      width: HEAPU32[ptr >> 2],
      height: HEAPU32[(ptr + 4) >> 2],
      depthOrArrayLayers: HEAPU32[(ptr + 8) >> 2],
    };
  },
  makeOrigin3D: (ptr) => {
    return {
      x: HEAPU32[ptr >> 2],
      y: HEAPU32[(ptr + 4) >> 2],
      z: HEAPU32[(ptr + 8) >> 2],
    };
  },
  makeImageCopyTexture: (ptr) => {
    assert(ptr);
    assert(HEAPU32[ptr >> 2] === 0);
    return {
      texture: WebGPU.mgrTexture.get(HEAPU32[(ptr + 4) >> 2]),
      mipLevel: HEAPU32[(ptr + 8) >> 2],
      origin: WebGPU.makeOrigin3D(ptr + 12),
      aspect: WebGPU.TextureAspect[HEAPU32[(ptr + 24) >> 2]],
    };
  },
  makeTextureDataLayout: (ptr) => {
    assert(ptr);
    assert(HEAPU32[ptr >> 2] === 0);
    var bytesPerRow = HEAPU32[(ptr + 16) >> 2];
    var rowsPerImage = HEAPU32[(ptr + 20) >> 2];
    return {
      offset:
        HEAPU32[(ptr + 4 + 8) >> 2] * 0x100000000 + HEAPU32[(ptr + 8) >> 2],
      bytesPerRow: bytesPerRow === 4294967295 ? undefined : bytesPerRow,
      rowsPerImage: rowsPerImage === 4294967295 ? undefined : rowsPerImage,
    };
  },
  makeImageCopyBuffer: (ptr) => {
    assert(ptr);
    assert(HEAPU32[ptr >> 2] === 0);
    var layoutPtr = ptr + 8;
    var bufferCopyView = WebGPU.makeTextureDataLayout(layoutPtr);
    bufferCopyView["buffer"] = WebGPU.mgrBuffer.get(HEAPU32[(ptr + 32) >> 2]);
    return bufferCopyView;
  },
  makePipelineConstants: (constantCount, constantsPtr) => {
    if (!constantCount) return;
    var constants = {};
    for (var i = 0; i < constantCount; ++i) {
      var entryPtr = constantsPtr + 16 * i;
      var key = UTF8ToString(HEAPU32[(entryPtr + 4) >> 2]);
      constants[key] = HEAPF64[(entryPtr + 8) >> 3];
    }
    return constants;
  },
  makePipelineLayout: (layoutPtr) => {
    if (!layoutPtr) return "auto";
    return WebGPU.mgrPipelineLayout.get(layoutPtr);
  },
  makeProgrammableStageDescriptor: (ptr) => {
    if (!ptr) return undefined;
    assert(ptr);
    assert(HEAPU32[ptr >> 2] === 0);
    var desc = {
      module: WebGPU.mgrShaderModule.get(HEAPU32[(ptr + 4) >> 2]),
      constants: WebGPU.makePipelineConstants(
        HEAPU32[(ptr + 12) >> 2],
        HEAPU32[(ptr + 16) >> 2]
      ),
    };
    var entryPointPtr = HEAPU32[(ptr + 8) >> 2];
    if (entryPointPtr) desc["entryPoint"] = UTF8ToString(entryPointPtr);
    return desc;
  },
  fillLimitStruct: (limits, supportedLimitsOutPtr) => {
    var limitsOutPtr = supportedLimitsOutPtr + 8;

    function setLimitValueU32(name, limitOffset) {
      var limitValue = limits[name];
      HEAP32[(limitsOutPtr + limitOffset) >> 2] = limitValue;
    }
    function setLimitValueU64(name, limitOffset) {
      var limitValue = limits[name];
      (tempI64 = [
        limitValue >>> 0,
        ((tempDouble = limitValue),
        +Math.abs(tempDouble) >= 1.0
          ? tempDouble > 0.0
            ? +Math.floor(tempDouble / 4294967296.0) >>> 0
            : ~~+Math.ceil(
                (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0
              ) >>> 0
          : 0),
      ]),
        (HEAP32[(limitsOutPtr + limitOffset) >> 2] = tempI64[0]),
        (HEAP32[(limitsOutPtr + (limitOffset + 4)) >> 2] = tempI64[1]);
    }

    setLimitValueU32("maxTextureDimension1D", 0);
    setLimitValueU32("maxTextureDimension2D", 4);
    setLimitValueU32("maxTextureDimension3D", 8);
    setLimitValueU32("maxTextureArrayLayers", 12);
    setLimitValueU32("maxBindGroups", 16);
    setLimitValueU32("maxBindGroupsPlusVertexBuffers", 20);
    setLimitValueU32("maxBindingsPerBindGroup", 24);
    setLimitValueU32("maxDynamicUniformBuffersPerPipelineLayout", 28);
    setLimitValueU32("maxDynamicStorageBuffersPerPipelineLayout", 32);
    setLimitValueU32("maxSampledTexturesPerShaderStage", 36);
    setLimitValueU32("maxSamplersPerShaderStage", 40);
    setLimitValueU32("maxStorageBuffersPerShaderStage", 44);
    setLimitValueU32("maxStorageTexturesPerShaderStage", 48);
    setLimitValueU32("maxUniformBuffersPerShaderStage", 52);
    setLimitValueU32("minUniformBufferOffsetAlignment", 72);
    setLimitValueU32("minStorageBufferOffsetAlignment", 76);

    setLimitValueU64("maxUniformBufferBindingSize", 56);
    setLimitValueU64("maxStorageBufferBindingSize", 64);

    setLimitValueU32("maxVertexBuffers", 80);
    setLimitValueU64("maxBufferSize", 88);
    setLimitValueU32("maxVertexAttributes", 96);
    setLimitValueU32("maxVertexBufferArrayStride", 100);
    setLimitValueU32("maxInterStageShaderComponents", 104);
    setLimitValueU32("maxInterStageShaderVariables", 108);
    setLimitValueU32("maxColorAttachments", 112);
    setLimitValueU32("maxColorAttachmentBytesPerSample", 116);
    setLimitValueU32("maxComputeWorkgroupStorageSize", 120);
    setLimitValueU32("maxComputeInvocationsPerWorkgroup", 124);
    setLimitValueU32("maxComputeWorkgroupSizeX", 128);
    setLimitValueU32("maxComputeWorkgroupSizeY", 132);
    setLimitValueU32("maxComputeWorkgroupSizeZ", 136);
    setLimitValueU32("maxComputeWorkgroupsPerDimension", 140);
  },
  Int_BufferMapState: {
    unmapped: 1,
    pending: 2,
    mapped: 3,
  },
  Int_CompilationMessageType: {
    error: 1,
    warning: 2,
    info: 3,
  },
  Int_DeviceLostReason: {
    undefined: 1,
    unknown: 1,
    destroyed: 2,
  },
  Int_PreferredFormat: {
    rgba8unorm: 18,
    bgra8unorm: 23,
  },
  WGSLFeatureName: [
    ,
    "readonly_and_readwrite_storage_textures",
    "packed_4x8_integer_dot_product",
    "unrestricted_pointer_parameters",
    "pointer_composite_access",
  ],
  AddressMode: [, "clamp-to-edge", "repeat", "mirror-repeat"],
  AlphaMode: [, "opaque", "premultiplied"],
  BlendFactor: [
    ,
    "zero",
    "one",
    "src",
    "one-minus-src",
    "src-alpha",
    "one-minus-src-alpha",
    "dst",
    "one-minus-dst",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "constant",
    "one-minus-constant",
  ],
  BlendOperation: [, "add", "subtract", "reverse-subtract", "min", "max"],
  BufferBindingType: [, "uniform", "storage", "read-only-storage"],
  BufferMapState: {
    1: "unmapped",
    2: "pending",
    3: "mapped",
  },
  CompareFunction: [
    ,
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always",
  ],
  CompilationInfoRequestStatus: ["success", "error", "device-lost", "unknown"],
  CullMode: [, "none", "front", "back"],
  ErrorFilter: {
    1: "validation",
    2: "out-of-memory",
    3: "internal",
  },
  FeatureName: [
    ,
    "depth-clip-control",
    "depth32float-stencil8",
    "timestamp-query",
    "texture-compression-bc",
    "texture-compression-etc2",
    "texture-compression-astc",
    "indirect-first-instance",
    "shader-f16",
    "rg11b10ufloat-renderable",
    "bgra8unorm-storage",
    "float32-filterable",
  ],
  FilterMode: [, "nearest", "linear"],
  FrontFace: [, "ccw", "cw"],
  IndexFormat: [, "uint16", "uint32"],
  LoadOp: [, "clear", "load"],
  MipmapFilterMode: [, "nearest", "linear"],
  PowerPreference: [, "low-power", "high-performance"],
  PrimitiveTopology: [
    ,
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip",
  ],
  QueryType: {
    1: "occlusion",
    2: "timestamp",
  },
  SamplerBindingType: [, "filtering", "non-filtering", "comparison"],
  StencilOperation: [
    ,
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap",
  ],
  StorageTextureAccess: [, "write-only", "read-only", "read-write"],
  StoreOp: [, "store", "discard"],
  TextureAspect: [, "all", "stencil-only", "depth-only"],
  TextureDimension: [, "1d", "2d", "3d"],
  TextureFormat: [
    ,
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",
    "r32float",
    "r32uint",
    "r32sint",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    "rgb10a2uint",
    "rgb10a2unorm",
    "rg11b10ufloat",
    "rgb9e5ufloat",
    "rg32float",
    "rg32uint",
    "rg32sint",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",
    "rgba32float",
    "rgba32uint",
    "rgba32sint",
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",
    "depth32float-stencil8",
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",
    "etc2-rgb8unorm",
    "etc2-rgb8unorm-srgb",
    "etc2-rgb8a1unorm",
    "etc2-rgb8a1unorm-srgb",
    "etc2-rgba8unorm",
    "etc2-rgba8unorm-srgb",
    "eac-r11unorm",
    "eac-r11snorm",
    "eac-rg11unorm",
    "eac-rg11snorm",
    "astc-4x4-unorm",
    "astc-4x4-unorm-srgb",
    "astc-5x4-unorm",
    "astc-5x4-unorm-srgb",
    "astc-5x5-unorm",
    "astc-5x5-unorm-srgb",
    "astc-6x5-unorm",
    "astc-6x5-unorm-srgb",
    "astc-6x6-unorm",
    "astc-6x6-unorm-srgb",
    "astc-8x5-unorm",
    "astc-8x5-unorm-srgb",
    "astc-8x6-unorm",
    "astc-8x6-unorm-srgb",
    "astc-8x8-unorm",
    "astc-8x8-unorm-srgb",
    "astc-10x5-unorm",
    "astc-10x5-unorm-srgb",
    "astc-10x6-unorm",
    "astc-10x6-unorm-srgb",
    "astc-10x8-unorm",
    "astc-10x8-unorm-srgb",
    "astc-10x10-unorm",
    "astc-10x10-unorm-srgb",
    "astc-12x10-unorm",
    "astc-12x10-unorm-srgb",
    "astc-12x12-unorm",
    "astc-12x12-unorm-srgb",
  ],
  TextureSampleType: [, "float", "unfilterable-float", "depth", "sint", "uint"],
  TextureViewDimension: [, "1d", "2d", "2d-array", "cube", "cube-array", "3d"],
  VertexFormat: [
    ,
    "uint8x2",
    "uint8x4",
    "sint8x2",
    "sint8x4",
    "unorm8x2",
    "unorm8x4",
    "snorm8x2",
    "snorm8x4",
    "uint16x2",
    "uint16x4",
    "sint16x2",
    "sint16x4",
    "unorm16x2",
    "unorm16x4",
    "snorm16x2",
    "snorm16x4",
    "float16x2",
    "float16x4",
    "float32",
    "float32x2",
    "float32x3",
    "float32x4",
    "uint32",
    "uint32x2",
    "uint32x3",
    "uint32x4",
    "sint32",
    "sint32x2",
    "sint32x3",
    "sint32x4",
    "unorm10-10-10-2",
  ],
  VertexStepMode: [, "vertex-buffer-not-used", "vertex", "instance"],
  FeatureNameString2Enum: {
    undefined: "0",
    "depth-clip-control": "1",
    "depth32float-stencil8": "2",
    "timestamp-query": "3",
    "texture-compression-bc": "4",
    "texture-compression-etc2": "5",
    "texture-compression-astc": "6",
    "indirect-first-instance": "7",
    "shader-f16": "8",
    "rg11b10ufloat-renderable": "9",
    "bgra8unorm-storage": "10",
    "float32-filterable": "11",
  },
};
var _wgpuAdapterRelease = (id) => WebGPU.mgrAdapter.release(id);

var _wgpuAdapterRequestDevice = (adapterId, descriptor, callback, userdata) => {
  var adapter = WebGPU.mgrAdapter.get(adapterId);

  var desc = {};
  if (descriptor) {
    assert(descriptor);
    assert(HEAPU32[descriptor >> 2] === 0);
    var requiredFeatureCount = HEAPU32[(descriptor + 8) >> 2];
    if (requiredFeatureCount) {
      var requiredFeaturesPtr = HEAPU32[(descriptor + 12) >> 2];
      // requiredFeaturesPtr is a pointer to an array of FeatureName which is an enum of size uint32_t
      desc["requiredFeatures"] = Array.from(
        HEAPU32.subarray(
          requiredFeaturesPtr >> 2,
          (requiredFeaturesPtr + requiredFeatureCount * 4) >> 2
        ),
        (feature) => WebGPU.FeatureName[feature]
      );
    }
    var requiredLimitsPtr = HEAPU32[(descriptor + 16) >> 2];
    if (requiredLimitsPtr) {
      assert(requiredLimitsPtr);
      assert(HEAPU32[requiredLimitsPtr >> 2] === 0);
      var limitsPtr = requiredLimitsPtr + 8;
      var requiredLimits = {};
      function setLimitU32IfDefined(name, limitOffset) {
        var ptr = limitsPtr + limitOffset;
        var value = HEAPU32[ptr >> 2];
        if (value != 4294967295) {
          requiredLimits[name] = value;
        }
      }
      function setLimitU64IfDefined(name, limitOffset) {
        var ptr = limitsPtr + limitOffset;
        // Handle WGPU_LIMIT_U64_UNDEFINED.
        var limitPart1 = HEAPU32[ptr >> 2];
        var limitPart2 = HEAPU32[(ptr + 4) >> 2];
        if (limitPart1 != 0xffffffff || limitPart2 != 0xffffffff) {
          requiredLimits[name] =
            HEAPU32[(ptr + 4) >> 2] * 0x100000000 + HEAPU32[ptr >> 2];
        }
      }

      setLimitU32IfDefined("maxTextureDimension1D", 0);
      setLimitU32IfDefined("maxTextureDimension2D", 4);
      setLimitU32IfDefined("maxTextureDimension3D", 8);
      setLimitU32IfDefined("maxTextureArrayLayers", 12);
      setLimitU32IfDefined("maxBindGroups", 16);
      setLimitU32IfDefined("maxBindGroupsPlusVertexBuffers", 20);
      setLimitU32IfDefined("maxDynamicUniformBuffersPerPipelineLayout", 28);
      setLimitU32IfDefined("maxDynamicStorageBuffersPerPipelineLayout", 32);
      setLimitU32IfDefined("maxSampledTexturesPerShaderStage", 36);
      setLimitU32IfDefined("maxSamplersPerShaderStage", 40);
      setLimitU32IfDefined("maxStorageBuffersPerShaderStage", 44);
      setLimitU32IfDefined("maxStorageTexturesPerShaderStage", 48);
      setLimitU32IfDefined("maxUniformBuffersPerShaderStage", 52);
      setLimitU32IfDefined("minUniformBufferOffsetAlignment", 72);
      setLimitU32IfDefined("minStorageBufferOffsetAlignment", 76);
      setLimitU64IfDefined("maxUniformBufferBindingSize", 56);
      setLimitU64IfDefined("maxStorageBufferBindingSize", 64);
      setLimitU32IfDefined("maxVertexBuffers", 80);
      setLimitU64IfDefined("maxBufferSize", 88);
      setLimitU32IfDefined("maxVertexAttributes", 96);
      setLimitU32IfDefined("maxVertexBufferArrayStride", 100);
      setLimitU32IfDefined("maxInterStageShaderComponents", 104);
      setLimitU32IfDefined("maxInterStageShaderVariables", 108);
      setLimitU32IfDefined("maxColorAttachments", 112);
      setLimitU32IfDefined("maxColorAttachmentBytesPerSample", 116);
      setLimitU32IfDefined("maxComputeWorkgroupStorageSize", 120);
      setLimitU32IfDefined("maxComputeInvocationsPerWorkgroup", 124);
      setLimitU32IfDefined("maxComputeWorkgroupSizeX", 128);
      setLimitU32IfDefined("maxComputeWorkgroupSizeY", 132);
      setLimitU32IfDefined("maxComputeWorkgroupSizeZ", 136);
      setLimitU32IfDefined("maxComputeWorkgroupsPerDimension", 140);
      desc["requiredLimits"] = requiredLimits;
    }

    var defaultQueuePtr = HEAPU32[(descriptor + 20) >> 2];
    if (defaultQueuePtr) {
      var defaultQueueDesc = {};
      var labelPtr = HEAPU32[(defaultQueuePtr + 4) >> 2];
      if (labelPtr) defaultQueueDesc["label"] = UTF8ToString(labelPtr);
      desc["defaultQueue"] = defaultQueueDesc;
    }

    var deviceLostCallbackPtr = HEAPU32[(descriptor + 28) >> 2];
    var deviceLostUserdataPtr = HEAPU32[(descriptor + 32) >> 2];

    var labelPtr = HEAPU32[(descriptor + 4) >> 2];
    if (labelPtr) desc["label"] = UTF8ToString(labelPtr);
  }

  adapter.requestDevice(desc).then(
    (device) => {
      callUserCallback(() => {
        var deviceWrapper = { queueId: WebGPU.mgrQueue.create(device.queue) };
        var deviceId = WebGPU.mgrDevice.create(device, deviceWrapper);
        if (deviceLostCallbackPtr) {
          device.lost.then((info) => {
            callUserCallback(() =>
              WebGPU.errorCallback(
                deviceLostCallbackPtr,
                WebGPU.Int_DeviceLostReason[info.reason],
                info.message,
                deviceLostUserdataPtr
              )
            );
          });
        }
        ((a1, a2, a3, a4) => dynCall_viiii(callback, a1, a2, a3, a4))(
          0,
          deviceId,
          0,
          userdata
        );
      });
    },
    function (ex) {
      callUserCallback(() => {
        var sp = stackSave();
        var messagePtr = stringToUTF8OnStack(ex.message);
        ((a1, a2, a3, a4) => dynCall_viiii(callback, a1, a2, a3, a4))(
          1,
          0,
          messagePtr,
          userdata
        );
        stackRestore(sp);
      });
    }
  );
};

var _wgpuBindGroupLayoutRelease = (id) => WebGPU.mgrBindGroupLayout.release(id);

var _wgpuBindGroupRelease = (id) => WebGPU.mgrBindGroup.release(id);

var _wgpuBufferDestroy = (bufferId) => {
  var bufferWrapper = WebGPU.mgrBuffer.objects[bufferId];
  assert(typeof bufferWrapper != "undefined");
  if (bufferWrapper.onUnmap) {
    for (var i = 0; i < bufferWrapper.onUnmap.length; ++i) {
      bufferWrapper.onUnmap[i]();
    }
    bufferWrapper.onUnmap = undefined;
  }

  WebGPU.mgrBuffer.get(bufferId).destroy();
};

var _wgpuBufferGetConstMappedRange = (bufferId, offset, size) => {
  var bufferWrapper = WebGPU.mgrBuffer.objects[bufferId];
  assert(typeof bufferWrapper != "undefined");

  if (size === 0)
    warnOnce("getMappedRange size=0 no longer means WGPU_WHOLE_MAP_SIZE");

  if (size == -1) size = undefined;

  var mapped;
  try {
    mapped = bufferWrapper.object.getMappedRange(offset, size);
  } catch (ex) {
    err(`wgpuBufferGetConstMappedRange(${offset}, ${size}) failed: ${ex}`);
    // TODO(kainino0x): Somehow inject a validation error?
    return 0;
  }
  var data = _memalign(16, mapped.byteLength);
  HEAPU8.set(new Uint8Array(mapped), data);
  bufferWrapper.onUnmap.push(() => _free(data));
  return data;
};

var _setTempRet0 = setTempRet0;

var _wgpuBufferGetSize = function (bufferId) {
  var ret = (() => {
    var buffer = WebGPU.mgrBuffer.get(bufferId);
    // 64-bit
    return buffer.size;
  })();
  return (
    setTempRet0(
      ((tempDouble = ret),
      +Math.abs(tempDouble) >= 1.0
        ? tempDouble > 0.0
          ? +Math.floor(tempDouble / 4294967296.0) >>> 0
          : ~~+Math.ceil(
              (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0
            ) >>> 0
        : 0)
    ),
    ret >>> 0
  );
};

var _wgpuBufferMapAsync = (
  bufferId,
  mode,
  offset,
  size,
  callback,
  userdata
) => {
  var bufferWrapper = WebGPU.mgrBuffer.objects[bufferId];
  assert(typeof bufferWrapper != "undefined");
  bufferWrapper.mapMode = mode;
  bufferWrapper.onUnmap = [];
  var buffer = bufferWrapper.object;

  if (size == -1) size = undefined;

  // `callback` takes (WGPUBufferMapAsyncStatus status, void * userdata)

  buffer.mapAsync(mode, offset, size).then(
    () => {
      callUserCallback(() => {
        ((a1, a2) => dynCall_vii(callback, a1, a2))(0, userdata);
      });
    },
    () => {
      callUserCallback(() => {
        // TODO(kainino0x): Figure out how to pick other error status values.
        ((a1, a2) => dynCall_vii(callback, a1, a2))(1, userdata);
      });
    }
  );
};

var _wgpuBufferUnmap = (bufferId) => {
  var bufferWrapper = WebGPU.mgrBuffer.objects[bufferId];
  assert(typeof bufferWrapper != "undefined");

  if (!bufferWrapper.onUnmap) {
    // Already unmapped
    return;
  }

  for (var i = 0; i < bufferWrapper.onUnmap.length; ++i) {
    bufferWrapper.onUnmap[i]();
  }
  bufferWrapper.onUnmap = undefined;

  bufferWrapper.object.unmap();
};

var _wgpuCommandBufferRelease = (id) => WebGPU.mgrCommandBuffer.release(id);

var _wgpuCommandEncoderBeginComputePass = (encoderId, descriptor) => {
  var desc;

  function makeComputePassTimestampWrites(twPtr) {
    if (twPtr === 0) return undefined;

    return {
      querySet: WebGPU.mgrQuerySet.get(HEAPU32[twPtr >> 2]),
      beginningOfPassWriteIndex: HEAPU32[(twPtr + 4) >> 2],
      endOfPassWriteIndex: HEAPU32[(twPtr + 8) >> 2],
    };
  }

  if (descriptor) {
    assert(descriptor);
    assert(HEAPU32[descriptor >> 2] === 0);
    desc = {
      label: undefined,
      timestampWrites: makeComputePassTimestampWrites(
        HEAPU32[(descriptor + 8) >> 2]
      ),
    };
    var labelPtr = HEAPU32[(descriptor + 4) >> 2];
    if (labelPtr) desc["label"] = UTF8ToString(labelPtr);
  }
  var commandEncoder = WebGPU.mgrCommandEncoder.get(encoderId);
  return WebGPU.mgrComputePassEncoder.create(
    commandEncoder.beginComputePass(desc)
  );
};

function _wgpuCommandEncoderClearBuffer(
  encoderId,
  bufferId,
  offset_low,
  offset_high,
  size_low,
  size_high
) {
  var offset = convertI32PairToI53Checked(offset_low, offset_high);
  var size = convertI32PairToI53Checked(size_low, size_high);

  var commandEncoder = WebGPU.mgrCommandEncoder.get(encoderId);
  if (size == -1) size = undefined;

  var buffer = WebGPU.mgrBuffer.get(bufferId);
  commandEncoder.clearBuffer(buffer, offset, size);
}

function _wgpuCommandEncoderCopyBufferToBuffer(
  encoderId,
  srcId,
  srcOffset_low,
  srcOffset_high,
  dstId,
  dstOffset_low,
  dstOffset_high,
  size_low,
  size_high
) {
  var srcOffset = convertI32PairToI53Checked(srcOffset_low, srcOffset_high);
  var dstOffset = convertI32PairToI53Checked(dstOffset_low, dstOffset_high);
  var size = convertI32PairToI53Checked(size_low, size_high);

  var commandEncoder = WebGPU.mgrCommandEncoder.get(encoderId);
  var src = WebGPU.mgrBuffer.get(srcId);
  var dst = WebGPU.mgrBuffer.get(dstId);
  commandEncoder.copyBufferToBuffer(src, srcOffset, dst, dstOffset, size);
}

var _wgpuCommandEncoderFinish = (encoderId, descriptor) => {
  // TODO: Use the descriptor.
  var commandEncoder = WebGPU.mgrCommandEncoder.get(encoderId);
  return WebGPU.mgrCommandBuffer.create(commandEncoder.finish());
};

var _wgpuCommandEncoderRelease = (id) => WebGPU.mgrCommandEncoder.release(id);

var _wgpuComputePassEncoderDispatchWorkgroups = (passId, x, y, z) => {
  var pass = WebGPU.mgrComputePassEncoder.get(passId);
  pass.dispatchWorkgroups(x, y, z);
};

var _wgpuComputePassEncoderEnd = (passId) => {
  var pass = WebGPU.mgrComputePassEncoder.get(passId);
  pass.end();
};

var _wgpuComputePassEncoderRelease = (id) =>
  WebGPU.mgrComputePassEncoder.release(id);

var _wgpuComputePassEncoderSetBindGroup = (
  passId,
  groupIndex,
  groupId,
  dynamicOffsetCount,
  dynamicOffsetsPtr
) => {
  var pass = WebGPU.mgrComputePassEncoder.get(passId);
  var group = WebGPU.mgrBindGroup.get(groupId);
  if (dynamicOffsetCount == 0) {
    pass.setBindGroup(groupIndex, group);
  } else {
    var offsets = [];
    for (var i = 0; i < dynamicOffsetCount; i++, dynamicOffsetsPtr += 4) {
      offsets.push(HEAPU32[dynamicOffsetsPtr >> 2]);
    }
    pass.setBindGroup(groupIndex, group, offsets);
  }
};

var _wgpuComputePassEncoderSetPipeline = (passId, pipelineId) => {
  var pass = WebGPU.mgrComputePassEncoder.get(passId);
  var pipeline = WebGPU.mgrComputePipeline.get(pipelineId);
  pass.setPipeline(pipeline);
};

var _wgpuComputePipelineRelease = (id) => WebGPU.mgrComputePipeline.release(id);

var readI53FromI64 = (ptr) => {
  return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;
};

var _wgpuDeviceCreateBindGroup = (deviceId, descriptor) => {
  assert(descriptor);
  assert(HEAPU32[descriptor >> 2] === 0);

  function makeEntry(entryPtr) {
    assert(entryPtr);

    var bufferId = HEAPU32[(entryPtr + 8) >> 2];
    var samplerId = HEAPU32[(entryPtr + 32) >> 2];
    var textureViewId = HEAPU32[(entryPtr + 36) >> 2];
    assert((bufferId !== 0) + (samplerId !== 0) + (textureViewId !== 0) === 1);

    var binding = HEAPU32[(entryPtr + 4) >> 2];

    if (bufferId) {
      var size = readI53FromI64(entryPtr + 24);
      if (size == -1) size = undefined;

      return {
        binding: binding,
        resource: {
          buffer: WebGPU.mgrBuffer.get(bufferId),
          offset:
            HEAPU32[(entryPtr + 4 + 16) >> 2] * 0x100000000 +
            HEAPU32[(entryPtr + 16) >> 2],
          size: size,
        },
      };
    } else if (samplerId) {
      return {
        binding: binding,
        resource: WebGPU.mgrSampler.get(samplerId),
      };
    } else {
      return {
        binding: binding,
        resource: WebGPU.mgrTextureView.get(textureViewId),
      };
    }
  }

  function makeEntries(count, entriesPtrs) {
    var entries = [];
    for (var i = 0; i < count; ++i) {
      entries.push(makeEntry(entriesPtrs + 40 * i));
    }
    return entries;
  }

  var desc = {
    label: undefined,
    layout: WebGPU.mgrBindGroupLayout.get(HEAPU32[(descriptor + 8) >> 2]),
    entries: makeEntries(
      HEAPU32[(descriptor + 12) >> 2],
      HEAPU32[(descriptor + 16) >> 2]
    ),
  };
  var labelPtr = HEAPU32[(descriptor + 4) >> 2];
  if (labelPtr) desc["label"] = UTF8ToString(labelPtr);

  var device = WebGPU.mgrDevice.get(deviceId);
  return WebGPU.mgrBindGroup.create(device.createBindGroup(desc));
};

var _wgpuDeviceCreateBindGroupLayout = (deviceId, descriptor) => {
  assert(descriptor);
  assert(HEAPU32[descriptor >> 2] === 0);

  function makeBufferEntry(entryPtr) {
    assert(entryPtr);

    var typeInt = HEAPU32[(entryPtr + 4) >> 2];
    if (!typeInt) return undefined;

    return {
      type: WebGPU.BufferBindingType[typeInt],
      hasDynamicOffset: !!HEAPU32[(entryPtr + 8) >> 2],
      minBindingSize:
        HEAPU32[(entryPtr + 4 + 16) >> 2] * 0x100000000 +
        HEAPU32[(entryPtr + 16) >> 2],
    };
  }

  function makeSamplerEntry(entryPtr) {
    assert(entryPtr);

    var typeInt = HEAPU32[(entryPtr + 4) >> 2];
    if (!typeInt) return undefined;

    return {
      type: WebGPU.SamplerBindingType[typeInt],
    };
  }

  function makeTextureEntry(entryPtr) {
    assert(entryPtr);

    var sampleTypeInt = HEAPU32[(entryPtr + 4) >> 2];
    if (!sampleTypeInt) return undefined;

    return {
      sampleType: WebGPU.TextureSampleType[sampleTypeInt],
      viewDimension: WebGPU.TextureViewDimension[HEAPU32[(entryPtr + 8) >> 2]],
      multisampled: !!HEAPU32[(entryPtr + 12) >> 2],
    };
  }

  function makeStorageTextureEntry(entryPtr) {
    assert(entryPtr);

    var accessInt = HEAPU32[(entryPtr + 4) >> 2];
    if (!accessInt) return undefined;

    return {
      access: WebGPU.StorageTextureAccess[accessInt],
      format: WebGPU.TextureFormat[HEAPU32[(entryPtr + 8) >> 2]],
      viewDimension: WebGPU.TextureViewDimension[HEAPU32[(entryPtr + 12) >> 2]],
    };
  }

  function makeEntry(entryPtr) {
    assert(entryPtr);

    return {
      binding: HEAPU32[(entryPtr + 4) >> 2],
      visibility: HEAPU32[(entryPtr + 8) >> 2],
      buffer: makeBufferEntry(entryPtr + 16),
      sampler: makeSamplerEntry(entryPtr + 40),
      texture: makeTextureEntry(entryPtr + 48),
      storageTexture: makeStorageTextureEntry(entryPtr + 64),
    };
  }

  function makeEntries(count, entriesPtrs) {
    var entries = [];
    for (var i = 0; i < count; ++i) {
      entries.push(makeEntry(entriesPtrs + 80 * i));
    }
    return entries;
  }

  var desc = {
    entries: makeEntries(
      HEAPU32[(descriptor + 8) >> 2],
      HEAPU32[(descriptor + 12) >> 2]
    ),
  };
  var labelPtr = HEAPU32[(descriptor + 4) >> 2];
  if (labelPtr) desc["label"] = UTF8ToString(labelPtr);

  var device = WebGPU.mgrDevice.get(deviceId);
  return WebGPU.mgrBindGroupLayout.create(device.createBindGroupLayout(desc));
};

var _wgpuDeviceCreateBuffer = (deviceId, descriptor) => {
  assert(descriptor);
  assert(HEAPU32[descriptor >> 2] === 0);

  var mappedAtCreation = !!HEAPU32[(descriptor + 24) >> 2];

  var desc = {
    label: undefined,
    usage: HEAPU32[(descriptor + 8) >> 2],
    size:
      HEAPU32[(descriptor + 4 + 16) >> 2] * 0x100000000 +
      HEAPU32[(descriptor + 16) >> 2],
    mappedAtCreation: mappedAtCreation,
  };
  var labelPtr = HEAPU32[(descriptor + 4) >> 2];
  if (labelPtr) desc["label"] = UTF8ToString(labelPtr);

  var device = WebGPU.mgrDevice.get(deviceId);
  var bufferWrapper = {};
  var id = WebGPU.mgrBuffer.create(device.createBuffer(desc), bufferWrapper);
  if (mappedAtCreation) {
    bufferWrapper.mapMode = 2;
    bufferWrapper.onUnmap = [];
  }
  return id;
};

var _wgpuDeviceCreateCommandEncoder = (deviceId, descriptor) => {
  var desc;
  if (descriptor) {
    assert(descriptor);
    assert(HEAPU32[descriptor >> 2] === 0);
    desc = {
      label: undefined,
    };
    var labelPtr = HEAPU32[(descriptor + 4) >> 2];
    if (labelPtr) desc["label"] = UTF8ToString(labelPtr);
  }
  var device = WebGPU.mgrDevice.get(deviceId);
  return WebGPU.mgrCommandEncoder.create(device.createCommandEncoder(desc));
};

var generateComputePipelineDesc = (descriptor) => {
  assert(descriptor);
  assert(HEAPU32[descriptor >> 2] === 0);

  var desc = {
    label: undefined,
    layout: WebGPU.makePipelineLayout(HEAPU32[(descriptor + 8) >> 2]),
    compute: WebGPU.makeProgrammableStageDescriptor(descriptor + 12),
  };
  var labelPtr = HEAPU32[(descriptor + 4) >> 2];
  if (labelPtr) desc["label"] = UTF8ToString(labelPtr);
  return desc;
};

var _wgpuDeviceCreateComputePipeline = (deviceId, descriptor) => {
  var desc = generateComputePipelineDesc(descriptor);
  var device = WebGPU.mgrDevice.get(deviceId);
  return WebGPU.mgrComputePipeline.create(device.createComputePipeline(desc));
};

var _wgpuDeviceCreatePipelineLayout = (deviceId, descriptor) => {
  assert(descriptor);
  assert(HEAPU32[descriptor >> 2] === 0);
  var bglCount = HEAPU32[(descriptor + 8) >> 2];
  var bglPtr = HEAPU32[(descriptor + 12) >> 2];
  var bgls = [];
  for (var i = 0; i < bglCount; ++i) {
    bgls.push(WebGPU.mgrBindGroupLayout.get(HEAPU32[(bglPtr + 4 * i) >> 2]));
  }
  var desc = {
    label: undefined,
    bindGroupLayouts: bgls,
  };
  var labelPtr = HEAPU32[(descriptor + 4) >> 2];
  if (labelPtr) desc["label"] = UTF8ToString(labelPtr);

  var device = WebGPU.mgrDevice.get(deviceId);
  return WebGPU.mgrPipelineLayout.create(device.createPipelineLayout(desc));
};

var _wgpuDeviceCreateShaderModule = (deviceId, descriptor) => {
  assert(descriptor);
  var nextInChainPtr = HEAPU32[descriptor >> 2];
  assert(nextInChainPtr !== 0);
  var sType = HEAPU32[(nextInChainPtr + 4) >> 2];

  var desc = {
    label: undefined,
    code: "",
  };
  var labelPtr = HEAPU32[(descriptor + 4) >> 2];
  if (labelPtr) desc["label"] = UTF8ToString(labelPtr);

  switch (sType) {
    case 5: {
      var count = HEAPU32[(nextInChainPtr + 8) >> 2];
      var start = HEAPU32[(nextInChainPtr + 12) >> 2];
      var offset = start >> 2;
      desc["code"] = HEAPU32.subarray(offset, offset + count);
      break;
    }
    case 6: {
      var sourcePtr = HEAPU32[(nextInChainPtr + 8) >> 2];
      if (sourcePtr) {
        desc["code"] = UTF8ToString(sourcePtr);
      }
      break;
    }
    default:
      abort("unrecognized ShaderModule sType");
  }

  var device = WebGPU.mgrDevice.get(deviceId);
  return WebGPU.mgrShaderModule.create(device.createShaderModule(desc));
};

var _wgpuDeviceGetQueue = (deviceId) => {
  var queueId = WebGPU.mgrDevice.objects[deviceId].queueId;
  assert(queueId, "wgpuDeviceGetQueue: queue was missing or null");
  // Returns a new reference to the existing queue.
  WebGPU.mgrQueue.reference(queueId);
  return queueId;
};

var _wgpuDeviceRelease = (id) => WebGPU.mgrDevice.release(id);

var _wgpuDeviceSetUncapturedErrorCallback = (deviceId, callback, userdata) => {
  var device = WebGPU.mgrDevice.get(deviceId);
  device.onuncapturederror = function (ev) {
    // This will skip the callback if the runtime is no longer alive.
    callUserCallback(() => {
      // WGPUErrorType type, const char* message, void* userdata
      var Validation = 0x00000001;
      var OutOfMemory = 0x00000002;
      var type;
      assert(typeof GPUValidationError != "undefined");
      assert(typeof GPUOutOfMemoryError != "undefined");
      if (ev.error instanceof GPUValidationError) type = Validation;
      else if (ev.error instanceof GPUOutOfMemoryError) type = OutOfMemory;
      // TODO: Implement GPUInternalError

      WebGPU.errorCallback(callback, type, ev.error.message, userdata);
    });
  };
};

var _wgpuInstanceRequestAdapter = (instanceId, options, callback, userdata) => {
  assert(
    instanceId === 1,
    "WGPUInstance must be created by wgpuCreateInstance"
  );

  var opts;
  if (options) {
    assert(options);
    assert(HEAPU32[options >> 2] === 0);
    opts = {
      powerPreference: WebGPU.PowerPreference[HEAPU32[(options + 8) >> 2]],
      forceFallbackAdapter: !!HEAPU32[(options + 16) >> 2],
    };
  }

  if (!("gpu" in navigator)) {
    var sp = stackSave();
    var messagePtr = stringToUTF8OnStack(
      "WebGPU not available on this browser (navigator.gpu is not available)"
    );
    ((a1, a2, a3, a4) => dynCall_viiii(callback, a1, a2, a3, a4))(
      1,
      0,
      messagePtr,
      userdata
    );
    stackRestore(sp);
    return;
  }

  navigator["gpu"]["requestAdapter"](opts).then(
    (adapter) => {
      callUserCallback(() => {
        if (adapter) {
          var adapterId = WebGPU.mgrAdapter.create(adapter);
          ((a1, a2, a3, a4) => dynCall_viiii(callback, a1, a2, a3, a4))(
            0,
            adapterId,
            0,
            userdata
          );
        } else {
          var sp = stackSave();
          var messagePtr = stringToUTF8OnStack(
            "WebGPU not available on this system (requestAdapter returned null)"
          );
          ((a1, a2, a3, a4) => dynCall_viiii(callback, a1, a2, a3, a4))(
            1,
            0,
            messagePtr,
            userdata
          );
          stackRestore(sp);
        }
      });
    },
    (ex) => {
      callUserCallback(() => {
        var sp = stackSave();
        var messagePtr = stringToUTF8OnStack(ex.message);
        ((a1, a2, a3, a4) => dynCall_viiii(callback, a1, a2, a3, a4))(
          2,
          0,
          messagePtr,
          userdata
        );
        stackRestore(sp);
      });
    }
  );
};

var _wgpuPipelineLayoutRelease = (id) => WebGPU.mgrPipelineLayout.release(id);

var _wgpuQueueOnSubmittedWorkDone = (queueId, callback, userdata) => {
  var queue = WebGPU.mgrQueue.get(queueId);

  queue.onSubmittedWorkDone().then(
    () => {
      callUserCallback(() => {
        ((a1, a2) => dynCall_vii(callback, a1, a2))(0, userdata);
      });
    },
    () => {
      callUserCallback(() => {
        ((a1, a2) => dynCall_vii(callback, a1, a2))(1, userdata);
      });
    }
  );
};

var _wgpuQueueRelease = (id) => WebGPU.mgrQueue.release(id);

var _wgpuQueueSubmit = (queueId, commandCount, commands) => {
  assert(commands % 4 === 0);
  var queue = WebGPU.mgrQueue.get(queueId);
  var cmds = Array.from(
    HEAP32.subarray(commands >> 2, (commands + commandCount * 4) >> 2),
    (id) => WebGPU.mgrCommandBuffer.get(id)
  );
  queue.submit(cmds);
};

function _wgpuQueueWriteBuffer(
  queueId,
  bufferId,
  bufferOffset_low,
  bufferOffset_high,
  data,
  size
) {
  var bufferOffset = convertI32PairToI53Checked(
    bufferOffset_low,
    bufferOffset_high
  );

  var queue = WebGPU.mgrQueue.get(queueId);
  var buffer = WebGPU.mgrBuffer.get(bufferId);
  // There is a size limitation for ArrayBufferView. Work around by passing in a subarray
  // instead of the whole heap. crbug.com/1201109
  var subarray = HEAPU8.subarray(data, data + size);
  queue.writeBuffer(buffer, bufferOffset, subarray, 0, size);
}

var _wgpuShaderModuleRelease = (id) => WebGPU.mgrShaderModule.release(id);

var wasmTableMirror = [];

/** @type {WebAssembly.Table} */
var wasmTable;
var getWasmTableEntry = (funcPtr) => {
  var func = wasmTableMirror[funcPtr];
  if (!func) {
    if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
    /** @suppress {checkTypes} */
    wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
  }
  /** @suppress {checkTypes} */
  assert(
    wasmTable.get(funcPtr) == func,
    "JavaScript-side Wasm function table mirror is out of date!"
  );
  return func;
};

var runAndAbortIfError = (func) => {
  try {
    return func();
  } catch (e) {
    abort(e);
  }
};

var sigToWasmTypes = (sig) => {
  assert(
    !sig.includes("j"),
    "i64 not permitted in function signatures when WASM_BIGINT is disabled"
  );
  var typeNames = {
    i: "i32",
    j: "i64",
    f: "f32",
    d: "f64",
    e: "externref",
    p: "i32",
  };
  var type = {
    parameters: [],
    results: sig[0] == "v" ? [] : [typeNames[sig[0]]],
  };
  for (var i = 1; i < sig.length; ++i) {
    assert(sig[i] in typeNames, "invalid signature char: " + sig[i]);
    type.parameters.push(typeNames[sig[i]]);
  }
  return type;
};

var runtimeKeepalivePush = () => {
  runtimeKeepaliveCounter += 1;
};

var runtimeKeepalivePop = () => {
  assert(runtimeKeepaliveCounter > 0);
  runtimeKeepaliveCounter -= 1;
};

var Asyncify = {
  instrumentWasmImports(imports) {
    var importPattern = /^(emscripten_sleep|invoke_.*|__asyncjs__.*)$/;

    for (let [x, original] of Object.entries(imports)) {
      if (typeof original == "function") {
        let isAsyncifyImport = original.isAsync || importPattern.test(x);
        imports[x] = (...args) => {
          var originalAsyncifyState = Asyncify.state;
          try {
            return original(...args);
          } finally {
            // Only asyncify-declared imports are allowed to change the
            // state.
            // Changing the state from normal to disabled is allowed (in any
            // function) as that is what shutdown does (and we don't have an
            // explicit list of shutdown imports).
            var changedToDisabled =
              originalAsyncifyState === Asyncify.State.Normal &&
              Asyncify.state === Asyncify.State.Disabled;
            // invoke_* functions are allowed to change the state if we do
            // not ignore indirect calls.
            var ignoredInvoke = x.startsWith("invoke_") && true;
            if (
              Asyncify.state !== originalAsyncifyState &&
              !isAsyncifyImport &&
              !changedToDisabled &&
              !ignoredInvoke
            ) {
              throw new Error(
                `import ${x} was not in ASYNCIFY_IMPORTS, but changed the state`
              );
            }
          }
        };
      }
    }
  },
  instrumentWasmExports(exports) {
    var ret = {};
    for (let [x, original] of Object.entries(exports)) {
      if (typeof original == "function") {
        ret[x] = (...args) => {
          Asyncify.exportCallStack.push(x);
          try {
            return original(...args);
          } finally {
            if (!ABORT) {
              var y = Asyncify.exportCallStack.pop();
              assert(y === x);
              Asyncify.maybeStopUnwind();
            }
          }
        };
      } else {
        ret[x] = original;
      }
    }
    return ret;
  },
  State: {
    Normal: 0,
    Unwinding: 1,
    Rewinding: 2,
    Disabled: 3,
  },
  state: 0,
  StackSize: 4194304,
  currData: null,
  handleSleepReturnValue: 0,
  exportCallStack: [],
  callStackNameToId: {},
  callStackIdToName: {},
  callStackId: 0,
  asyncPromiseHandlers: null,
  sleepCallbacks: [],
  getCallStackId(funcName) {
    var id = Asyncify.callStackNameToId[funcName];
    if (id === undefined) {
      id = Asyncify.callStackId++;
      Asyncify.callStackNameToId[funcName] = id;
      Asyncify.callStackIdToName[id] = funcName;
    }
    return id;
  },
  maybeStopUnwind() {
    if (
      Asyncify.currData &&
      Asyncify.state === Asyncify.State.Unwinding &&
      Asyncify.exportCallStack.length === 0
    ) {
      // We just finished unwinding.
      // Be sure to set the state before calling any other functions to avoid
      // possible infinite recursion here (For example in debug pthread builds
      // the dbg() function itself can call back into WebAssembly to get the
      // current pthread_self() pointer).
      Asyncify.state = Asyncify.State.Normal;

      // Keep the runtime alive so that a re-wind can be done later.
      runAndAbortIfError(_asyncify_stop_unwind);
      if (typeof Fibers != "undefined") {
        Fibers.trampoline();
      }
    }
  },
  whenDone() {
    assert(
      Asyncify.currData,
      "Tried to wait for an async operation when none is in progress."
    );
    assert(
      !Asyncify.asyncPromiseHandlers,
      "Cannot have multiple async operations in flight at once"
    );
    return new Promise((resolve, reject) => {
      Asyncify.asyncPromiseHandlers = { resolve, reject };
    });
  },
  allocateData() {
    // An asyncify data structure has three fields:
    //  0  current stack pos
    //  4  max stack pos
    //  8  id of function at bottom of the call stack (callStackIdToName[id] == name of js function)
    //
    // The Asyncify ABI only interprets the first two fields, the rest is for the runtime.
    // We also embed a stack in the same memory region here, right next to the structure.
    // This struct is also defined as asyncify_data_t in emscripten/fiber.h
    var ptr = _malloc(12 + Asyncify.StackSize);
    Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
    Asyncify.setDataRewindFunc(ptr);
    return ptr;
  },
  setDataHeader(ptr, stack, stackSize) {
    HEAPU32[ptr >> 2] = stack;
    HEAPU32[(ptr + 4) >> 2] = stack + stackSize;
  },
  setDataRewindFunc(ptr) {
    var bottomOfCallStack = Asyncify.exportCallStack[0];
    var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
    HEAP32[(ptr + 8) >> 2] = rewindId;
  },
  getDataRewindFuncName(ptr) {
    var id = HEAP32[(ptr + 8) >> 2];
    var name = Asyncify.callStackIdToName[id];
    return name;
  },
  getDataRewindFunc(name) {
    var func = wasmExports[name];
    return func;
  },
  doRewind(ptr) {
    var name = Asyncify.getDataRewindFuncName(ptr);
    var func = Asyncify.getDataRewindFunc(name);
    // Once we have rewound and the stack we no longer need to artificially
    // keep the runtime alive.

    return func();
  },
  handleSleep(startAsync) {
    assert(
      Asyncify.state !== Asyncify.State.Disabled,
      "Asyncify cannot be done during or after the runtime exits"
    );
    if (ABORT) return;
    if (Asyncify.state === Asyncify.State.Normal) {
      // Prepare to sleep. Call startAsync, and see what happens:
      // if the code decided to call our callback synchronously,
      // then no async operation was in fact begun, and we don't
      // need to do anything.
      var reachedCallback = false;
      var reachedAfterCallback = false;
      startAsync((handleSleepReturnValue = 0) => {
        assert(
          !handleSleepReturnValue ||
            typeof handleSleepReturnValue == "number" ||
            typeof handleSleepReturnValue == "boolean"
        ); // old emterpretify API supported other stuff
        if (ABORT) return;
        Asyncify.handleSleepReturnValue = handleSleepReturnValue;
        reachedCallback = true;
        if (!reachedAfterCallback) {
          // We are happening synchronously, so no need for async.
          return;
        }
        // This async operation did not happen synchronously, so we did
        // unwind. In that case there can be no compiled code on the stack,
        // as it might break later operations (we can rewind ok now, but if
        // we unwind again, we would unwind through the extra compiled code
        // too).
        assert(
          !Asyncify.exportCallStack.length,
          "Waking up (starting to rewind) must be done from JS, without compiled code on the stack."
        );
        Asyncify.state = Asyncify.State.Rewinding;
        runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
        if (typeof MainLoop != "undefined" && MainLoop.func) {
          MainLoop.resume();
        }
        var asyncWasmReturnValue,
          isError = false;
        try {
          asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
        } catch (err) {
          asyncWasmReturnValue = err;
          isError = true;
        }
        // Track whether the return value was handled by any promise handlers.
        var handled = false;
        if (!Asyncify.currData) {
          // All asynchronous execution has finished.
          // `asyncWasmReturnValue` now contains the final
          // return value of the exported async WASM function.
          //
          // Note: `asyncWasmReturnValue` is distinct from
          // `Asyncify.handleSleepReturnValue`.
          // `Asyncify.handleSleepReturnValue` contains the return
          // value of the last C function to have executed
          // `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`
          // contains the return value of the exported WASM function
          // that may have called C functions that
          // call `Asyncify.handleSleep()`.
          var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
          if (asyncPromiseHandlers) {
            Asyncify.asyncPromiseHandlers = null;
            (isError
              ? asyncPromiseHandlers.reject
              : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
            handled = true;
          }
        }
        if (isError && !handled) {
          // If there was an error and it was not handled by now, we have no choice but to
          // rethrow that error into the global scope where it can be caught only by
          // `onerror` or `onunhandledpromiserejection`.
          throw asyncWasmReturnValue;
        }
      });
      reachedAfterCallback = true;
      if (!reachedCallback) {
        // A true async operation was begun; start a sleep.
        Asyncify.state = Asyncify.State.Unwinding;
        // TODO: reuse, don't alloc/free every sleep
        Asyncify.currData = Asyncify.allocateData();
        if (typeof MainLoop != "undefined" && MainLoop.func) {
          MainLoop.pause();
        }
        runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
      }
    } else if (Asyncify.state === Asyncify.State.Rewinding) {
      // Stop a resume.
      Asyncify.state = Asyncify.State.Normal;
      runAndAbortIfError(_asyncify_stop_rewind);
      _free(Asyncify.currData);
      Asyncify.currData = null;
      // Call all sleep callbacks now that the sleep-resume is all done.
      Asyncify.sleepCallbacks.forEach(callUserCallback);
    } else {
      abort(`invalid state: ${Asyncify.state}`);
    }
    return Asyncify.handleSleepReturnValue;
  },
  handleAsync(startAsync) {
    return Asyncify.handleSleep((wakeUp) => {
      // TODO: add error handling as a second param when handleSleep implements it.
      startAsync().then(wakeUp);
    });
  },
};

var FS_createPath = FS.createPath;

var FS_unlink = (path) => FS.unlink(path);

var FS_createLazyFile = FS.createLazyFile;

var FS_createDevice = FS.createDevice;

FS.createPreloadedFile = FS_createPreloadedFile;
FS.staticInit();
// Set module methods based on EXPORTED_RUNTIME_METHODS
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_unlink"] = FS.unlink;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createDevice"] = FS.createDevice;
WebGPU.initManagers();
function checkIncomingModuleAPI() {
  ignoredModuleProp("fetchSettings");
}
var wasmImports = {
  /** @export */
  __assert_fail: ___assert_fail,
  /** @export */
  __call_sighandler: ___call_sighandler,
  /** @export */
  __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,
  /** @export */
  __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,
  /** @export */
  __cxa_throw: ___cxa_throw,
  /** @export */
  __resumeException: ___resumeException,
  /** @export */
  __syscall_fcntl64: ___syscall_fcntl64,
  /** @export */
  __syscall_fstat64: ___syscall_fstat64,
  /** @export */
  __syscall_getcwd: ___syscall_getcwd,
  /** @export */
  __syscall_getdents64: ___syscall_getdents64,
  /** @export */
  __syscall_ioctl: ___syscall_ioctl,
  /** @export */
  __syscall_lstat64: ___syscall_lstat64,
  /** @export */
  __syscall_newfstatat: ___syscall_newfstatat,
  /** @export */
  __syscall_openat: ___syscall_openat,
  /** @export */
  __syscall_stat64: ___syscall_stat64,
  /** @export */
  _abort_js: __abort_js,
  /** @export */
  _emscripten_memcpy_js: __emscripten_memcpy_js,
  /** @export */
  _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
  /** @export */
  _munmap_js: __munmap_js,
  /** @export */
  _tzset_js: __tzset_js,
  /** @export */
  clock_time_get: _clock_time_get,
  /** @export */
  emscripten_date_now: _emscripten_date_now,
  /** @export */
  emscripten_get_heap_max: _emscripten_get_heap_max,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  emscripten_sleep: _emscripten_sleep,
  /** @export */
  environ_get: _environ_get,
  /** @export */
  environ_sizes_get: _environ_sizes_get,
  /** @export */
  exit: _exit,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_read: _fd_read,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_write: _fd_write,
  /** @export */
  invoke_ii,
  /** @export */
  invoke_iii,
  /** @export */
  invoke_iiii,
  /** @export */
  invoke_vi,
  /** @export */
  invoke_vii,
  /** @export */
  invoke_viiii,
  /** @export */
  proc_exit: _proc_exit,
  /** @export */
  random_get: _random_get,
  /** @export */
  wgpuAdapterRelease: _wgpuAdapterRelease,
  /** @export */
  wgpuAdapterRequestDevice: _wgpuAdapterRequestDevice,
  /** @export */
  wgpuBindGroupLayoutRelease: _wgpuBindGroupLayoutRelease,
  /** @export */
  wgpuBindGroupRelease: _wgpuBindGroupRelease,
  /** @export */
  wgpuBufferDestroy: _wgpuBufferDestroy,
  /** @export */
  wgpuBufferGetConstMappedRange: _wgpuBufferGetConstMappedRange,
  /** @export */
  wgpuBufferGetSize: _wgpuBufferGetSize,
  /** @export */
  wgpuBufferMapAsync: _wgpuBufferMapAsync,
  /** @export */
  wgpuBufferUnmap: _wgpuBufferUnmap,
  /** @export */
  wgpuCommandBufferRelease: _wgpuCommandBufferRelease,
  /** @export */
  wgpuCommandEncoderBeginComputePass: _wgpuCommandEncoderBeginComputePass,
  /** @export */
  wgpuCommandEncoderClearBuffer: _wgpuCommandEncoderClearBuffer,
  /** @export */
  wgpuCommandEncoderCopyBufferToBuffer: _wgpuCommandEncoderCopyBufferToBuffer,
  /** @export */
  wgpuCommandEncoderFinish: _wgpuCommandEncoderFinish,
  /** @export */
  wgpuCommandEncoderRelease: _wgpuCommandEncoderRelease,
  /** @export */
  wgpuComputePassEncoderDispatchWorkgroups:
    _wgpuComputePassEncoderDispatchWorkgroups,
  /** @export */
  wgpuComputePassEncoderEnd: _wgpuComputePassEncoderEnd,
  /** @export */
  wgpuComputePassEncoderRelease: _wgpuComputePassEncoderRelease,
  /** @export */
  wgpuComputePassEncoderSetBindGroup: _wgpuComputePassEncoderSetBindGroup,
  /** @export */
  wgpuComputePassEncoderSetPipeline: _wgpuComputePassEncoderSetPipeline,
  /** @export */
  wgpuComputePipelineRelease: _wgpuComputePipelineRelease,
  /** @export */
  wgpuDeviceCreateBindGroup: _wgpuDeviceCreateBindGroup,
  /** @export */
  wgpuDeviceCreateBindGroupLayout: _wgpuDeviceCreateBindGroupLayout,
  /** @export */
  wgpuDeviceCreateBuffer: _wgpuDeviceCreateBuffer,
  /** @export */
  wgpuDeviceCreateCommandEncoder: _wgpuDeviceCreateCommandEncoder,
  /** @export */
  wgpuDeviceCreateComputePipeline: _wgpuDeviceCreateComputePipeline,
  /** @export */
  wgpuDeviceCreatePipelineLayout: _wgpuDeviceCreatePipelineLayout,
  /** @export */
  wgpuDeviceCreateShaderModule: _wgpuDeviceCreateShaderModule,
  /** @export */
  wgpuDeviceGetQueue: _wgpuDeviceGetQueue,
  /** @export */
  wgpuDeviceRelease: _wgpuDeviceRelease,
  /** @export */
  wgpuDeviceSetUncapturedErrorCallback: _wgpuDeviceSetUncapturedErrorCallback,
  /** @export */
  wgpuInstanceRequestAdapter: _wgpuInstanceRequestAdapter,
  /** @export */
  wgpuPipelineLayoutRelease: _wgpuPipelineLayoutRelease,
  /** @export */
  wgpuQueueOnSubmittedWorkDone: _wgpuQueueOnSubmittedWorkDone,
  /** @export */
  wgpuQueueRelease: _wgpuQueueRelease,
  /** @export */
  wgpuQueueSubmit: _wgpuQueueSubmit,
  /** @export */
  wgpuQueueWriteBuffer: _wgpuQueueWriteBuffer,
  /** @export */
  wgpuShaderModuleRelease: _wgpuShaderModuleRelease,
};
var wasmExports;
createWasm();
var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors", 0);
var _wgpuRequestAdapterSync = (Module["_wgpuRequestAdapterSync"] =
  createExportWrapper("wgpuRequestAdapterSync", 1));
var _wgpuRequestDeviceSync = (Module["_wgpuRequestDeviceSync"] =
  createExportWrapper("wgpuRequestDeviceSync", 2));
var _wgpuBufferMapSync = (Module["_wgpuBufferMapSync"] = createExportWrapper(
  "wgpuBufferMapSync",
  4
));
var _wgpuDeviceSynchronize = (Module["_wgpuDeviceSynchronize"] =
  createExportWrapper("wgpuDeviceSynchronize", 2));
var __ZN5boost13serialization16singleton_module8get_lockEv = (Module[
  "__ZN5boost13serialization16singleton_module8get_lockEv"
] = createExportWrapper(
  "_ZN5boost13serialization16singleton_module8get_lockEv",
  1
));
var _main = (Module["_main"] = createExportWrapper("__main_argc_argv", 2));
var _free = createExportWrapper("free", 1);
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp12openssl_hashINS6_18openssl_sha2_256_tEE6digestEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp12openssl_hashINS6_18openssl_sha2_256_tEE6digestEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp12openssl_hashINS6_18openssl_sha2_256_tEE6digestEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp10field_polyINS6_9bn254_gmpEEEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp10field_polyINS6_9bn254_gmpEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp10field_polyINS6_9bn254_gmpEEEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp9bn254_gmpEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp9bn254_gmpEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp9bn254_gmpEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp11merkle_treeINS6_12openssl_hashINS6_18openssl_sha2_256_tEEEE12decommitmentEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp11merkle_treeINS6_12openssl_hashINS6_18openssl_sha2_256_tEEEE12decommitmentEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveEN6ligero2vm3zkp11merkle_treeINS6_12openssl_hashINS6_18openssl_sha2_256_tEEEE12decommitmentEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__26vectorImNS4_9allocatorImEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__213unordered_mapImN6ligero2vm3zkp12openssl_hashINS8_18openssl_sha2_256_tEE6digestENS4_4hashImEENS4_8equal_toImEENS4_9allocatorINS4_4pairIKmSC_EEEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__213unordered_mapImN6ligero2vm3zkp12openssl_hashINS8_18openssl_sha2_256_tEE6digestENS4_4hashImEENS4_8equal_toImEENS4_9allocatorINS4_4pairIKmSC_EEEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__213unordered_mapImN6ligero2vm3zkp12openssl_hashINS8_18openssl_sha2_256_tEE6digestENS4_4hashImEENS4_8equal_toImEENS4_9allocatorINS4_4pairIKmSC_EEEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__24pairIKmN6ligero2vm3zkp12openssl_hashINS9_18openssl_sha2_256_tEE6digestEEEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__24pairIKmN6ligero2vm3zkp12openssl_hashINS9_18openssl_sha2_256_tEE6digestEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__24pairIKmN6ligero2vm3zkp12openssl_hashINS9_18openssl_sha2_256_tEE6digestEEEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var __ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__26vectorIjNS4_9allocatorIjEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv =
  (Module[
    "__ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__26vectorIjNS4_9allocatorIjEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv"
  ] = createExportWrapper(
    "_ZNK5boost7archive6detail11oserializerINS0_15binary_oarchiveENSt3__26vectorIjNS4_9allocatorIjEEEEE16save_object_dataERNS1_14basic_oarchiveEPKv",
    3
  ));
var _malloc = createExportWrapper("malloc", 1);
var _ntohs = createExportWrapper("ntohs", 1);
var _htons = createExportWrapper("htons", 1);
var _fflush = createExportWrapper("fflush", 1);
var _strerror = createExportWrapper("strerror", 1);
var _htonl = createExportWrapper("htonl", 1);
var _emscripten_builtin_memalign = createExportWrapper(
  "emscripten_builtin_memalign",
  2
);
var _memalign = createExportWrapper("memalign", 2);
var __emscripten_tempret_set = createExportWrapper(
  "_emscripten_tempret_set",
  1
);
var _emscripten_stack_init = () =>
  (_emscripten_stack_init = wasmExports["emscripten_stack_init"])();
var _emscripten_stack_get_free = () =>
  (_emscripten_stack_get_free = wasmExports["emscripten_stack_get_free"])();
var _emscripten_stack_get_base = () =>
  (_emscripten_stack_get_base = wasmExports["emscripten_stack_get_base"])();
var _emscripten_stack_get_end = () =>
  (_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();
var __emscripten_stack_restore = (a0) =>
  (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(a0);
var __emscripten_stack_alloc = (a0) =>
  (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
var _emscripten_stack_get_current = () =>
  (_emscripten_stack_get_current =
    wasmExports["emscripten_stack_get_current"])();
var ___cxa_can_catch = createExportWrapper("__cxa_can_catch", 3);
var dynCall_ii = (Module["dynCall_ii"] = createExportWrapper("dynCall_ii", 2));
var dynCall_viii = (Module["dynCall_viii"] = createExportWrapper(
  "dynCall_viii",
  4
));
var dynCall_viiii = (Module["dynCall_viiii"] = createExportWrapper(
  "dynCall_viiii",
  5
));
var dynCall_vii = (Module["dynCall_vii"] = createExportWrapper(
  "dynCall_vii",
  3
));
var dynCall_vi = (Module["dynCall_vi"] = createExportWrapper("dynCall_vi", 2));
var dynCall_v = (Module["dynCall_v"] = createExportWrapper("dynCall_v", 1));
var dynCall_iii = (Module["dynCall_iii"] = createExportWrapper(
  "dynCall_iii",
  3
));
var dynCall_iiii = (Module["dynCall_iiii"] = createExportWrapper(
  "dynCall_iiii",
  4
));
var dynCall_iiiiiiiii = (Module["dynCall_iiiiiiiii"] = createExportWrapper(
  "dynCall_iiiiiiiii",
  9
));
var dynCall_iiiiii = (Module["dynCall_iiiiii"] = createExportWrapper(
  "dynCall_iiiiii",
  6
));
var dynCall_viiiiii = (Module["dynCall_viiiiii"] = createExportWrapper(
  "dynCall_viiiiii",
  7
));
var dynCall_iiiiiiii = (Module["dynCall_iiiiiiii"] = createExportWrapper(
  "dynCall_iiiiiiii",
  8
));
var dynCall_iiiii = (Module["dynCall_iiiii"] = createExportWrapper(
  "dynCall_iiiii",
  5
));
var dynCall_iiiiiii = (Module["dynCall_iiiiiii"] = createExportWrapper(
  "dynCall_iiiiiii",
  7
));
var dynCall_iiiiiiiiii = (Module["dynCall_iiiiiiiiii"] = createExportWrapper(
  "dynCall_iiiiiiiiii",
  10
));
var dynCall_iiid = (Module["dynCall_iiid"] = createExportWrapper(
  "dynCall_iiid",
  4
));
var dynCall_i = (Module["dynCall_i"] = createExportWrapper("dynCall_i", 1));
var dynCall_iij = (Module["dynCall_iij"] = createExportWrapper(
  "dynCall_iij",
  4
));
var dynCall_iiiijj = (Module["dynCall_iiiijj"] = createExportWrapper(
  "dynCall_iiiijj",
  8
));
var dynCall_iiij = (Module["dynCall_iiij"] = createExportWrapper(
  "dynCall_iiij",
  5
));
var dynCall_iiiijjj = (Module["dynCall_iiiijjj"] = createExportWrapper(
  "dynCall_iiiijjj",
  10
));
var dynCall_iiiij = (Module["dynCall_iiiij"] = createExportWrapper(
  "dynCall_iiiij",
  6
));
var dynCall_iiiiji = (Module["dynCall_iiiiji"] = createExportWrapper(
  "dynCall_iiiiji",
  7
));
var dynCall_jiji = (Module["dynCall_jiji"] = createExportWrapper(
  "dynCall_jiji",
  5
));
var dynCall_iidiiii = (Module["dynCall_iidiiii"] = createExportWrapper(
  "dynCall_iidiiii",
  7
));
var dynCall_viijii = (Module["dynCall_viijii"] = createExportWrapper(
  "dynCall_viijii",
  7
));
var dynCall_iiiiij = (Module["dynCall_iiiiij"] = createExportWrapper(
  "dynCall_iiiiij",
  7
));
var dynCall_iiiiid = (Module["dynCall_iiiiid"] = createExportWrapper(
  "dynCall_iiiiid",
  6
));
var dynCall_iiiiijj = (Module["dynCall_iiiiijj"] = createExportWrapper(
  "dynCall_iiiiijj",
  9
));
var dynCall_iiiiiijj = (Module["dynCall_iiiiiijj"] = createExportWrapper(
  "dynCall_iiiiiijj",
  10
));
var dynCall_viiiii = (Module["dynCall_viiiii"] = createExportWrapper(
  "dynCall_viiiii",
  6
));
var _asyncify_start_unwind = createExportWrapper("asyncify_start_unwind", 1);
var _asyncify_stop_unwind = createExportWrapper("asyncify_stop_unwind", 0);
var _asyncify_start_rewind = createExportWrapper("asyncify_start_rewind", 1);
var _asyncify_stop_rewind = createExportWrapper("asyncify_stop_rewind", 0);

function invoke_ii(index, a1) {
  var sp = stackSave();
  try {
    return dynCall_ii(index, a1);
  } catch (e) {
    stackRestore(sp);
    if (e !== e + 0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vi(index, a1) {
  var sp = stackSave();
  try {
    dynCall_vi(index, a1);
  } catch (e) {
    stackRestore(sp);
    if (e !== e + 0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiii(index, a1, a2, a3, a4) {
  var sp = stackSave();
  try {
    dynCall_viiii(index, a1, a2, a3, a4);
  } catch (e) {
    stackRestore(sp);
    if (e !== e + 0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index, a1, a2) {
  var sp = stackSave();
  try {
    dynCall_vii(index, a1, a2);
  } catch (e) {
    stackRestore(sp);
    if (e !== e + 0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiii(index, a1, a2, a3) {
  var sp = stackSave();
  try {
    return dynCall_iiii(index, a1, a2, a3);
  } catch (e) {
    stackRestore(sp);
    if (e !== e + 0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iii(index, a1, a2) {
  var sp = stackSave();
  try {
    return dynCall_iii(index, a1, a2);
  } catch (e) {
    stackRestore(sp);
    if (e !== e + 0) throw e;
    _setThrew(1, 0);
  }
}

// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module["addRunDependency"] = addRunDependency;
Module["removeRunDependency"] = removeRunDependency;
Module["callMain"] = callMain;
Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
Module["FS_unlink"] = FS_unlink;
Module["FS_createPath"] = FS_createPath;
Module["FS_createDevice"] = FS_createDevice;
Module["FS"] = FS;
Module["FS_createDataFile"] = FS_createDataFile;
Module["FS_createLazyFile"] = FS_createLazyFile;
var missingLibrarySymbols = [
  "writeI53ToI64",
  "writeI53ToI64Clamped",
  "writeI53ToI64Signaling",
  "writeI53ToU64Clamped",
  "writeI53ToU64Signaling",
  "readI53FromU64",
  "convertI32PairToI53",
  "convertU32PairToI53",
  "getTempRet0",
  "inetPton4",
  "inetNtop4",
  "inetPton6",
  "inetNtop6",
  "readSockaddr",
  "writeSockaddr",
  "emscriptenLog",
  "readEmAsmArgs",
  "jstoi_q",
  "listenOnce",
  "autoResumeAudioContext",
  "dynCallLegacy",
  "getDynCaller",
  "dynCall",
  "asmjsMangle",
  "HandleAllocator",
  "getNativeTypeSize",
  "STACK_SIZE",
  "STACK_ALIGN",
  "POINTER_SIZE",
  "ASSERTIONS",
  "getCFunc",
  "ccall",
  "cwrap",
  "uleb128Encode",
  "generateFuncType",
  "convertJsFunctionToWasm",
  "getEmptyTableSlot",
  "updateTableMap",
  "getFunctionAddress",
  "addFunction",
  "removeFunction",
  "reallyNegative",
  "unSign",
  "strLen",
  "reSign",
  "formatString",
  "intArrayToString",
  "AsciiToString",
  "UTF16ToString",
  "stringToUTF16",
  "lengthBytesUTF16",
  "UTF32ToString",
  "stringToUTF32",
  "lengthBytesUTF32",
  "stringToNewUTF8",
  "writeArrayToMemory",
  "registerKeyEventCallback",
  "maybeCStringToJsString",
  "findEventTarget",
  "getBoundingClientRect",
  "fillMouseEventData",
  "registerMouseEventCallback",
  "registerWheelEventCallback",
  "registerUiEventCallback",
  "registerFocusEventCallback",
  "fillDeviceOrientationEventData",
  "registerDeviceOrientationEventCallback",
  "fillDeviceMotionEventData",
  "registerDeviceMotionEventCallback",
  "screenOrientation",
  "fillOrientationChangeEventData",
  "registerOrientationChangeEventCallback",
  "fillFullscreenChangeEventData",
  "registerFullscreenChangeEventCallback",
  "JSEvents_requestFullscreen",
  "JSEvents_resizeCanvasForFullscreen",
  "registerRestoreOldStyle",
  "hideEverythingExceptGivenElement",
  "restoreHiddenElements",
  "setLetterbox",
  "softFullscreenResizeWebGLRenderTarget",
  "doRequestFullscreen",
  "fillPointerlockChangeEventData",
  "registerPointerlockChangeEventCallback",
  "registerPointerlockErrorEventCallback",
  "requestPointerLock",
  "fillVisibilityChangeEventData",
  "registerVisibilityChangeEventCallback",
  "registerTouchEventCallback",
  "fillGamepadEventData",
  "registerGamepadEventCallback",
  "registerBeforeUnloadEventCallback",
  "fillBatteryEventData",
  "battery",
  "registerBatteryEventCallback",
  "setCanvasElementSize",
  "getCanvasElementSize",
  "jsStackTrace",
  "getCallstack",
  "convertPCtoSourceLocation",
  "wasiRightsToMuslOFlags",
  "wasiOFlagsToMuslOFlags",
  "setImmediateWrapped",
  "safeRequestAnimationFrame",
  "clearImmediateWrapped",
  "polyfillSetImmediate",
  "registerPostMainLoop",
  "registerPreMainLoop",
  "getPromise",
  "makePromise",
  "idsToPromises",
  "makePromiseCallback",
  "Browser_asyncPrepareDataCounter",
  "isLeapYear",
  "ydayFromDate",
  "arraySum",
  "addDays",
  "getSocketFromFD",
  "getSocketAddress",
  "FS_mkdirTree",
  "_setNetworkCallback",
  "heapObjectForWebGLType",
  "toTypedArrayIndex",
  "webgl_enable_ANGLE_instanced_arrays",
  "webgl_enable_OES_vertex_array_object",
  "webgl_enable_WEBGL_draw_buffers",
  "webgl_enable_WEBGL_multi_draw",
  "webgl_enable_EXT_polygon_offset_clamp",
  "webgl_enable_EXT_clip_control",
  "webgl_enable_WEBGL_polygon_mode",
  "emscriptenWebGLGet",
  "computeUnpackAlignedImageSize",
  "colorChannelsInGlTextureFormat",
  "emscriptenWebGLGetTexPixelData",
  "emscriptenWebGLGetUniform",
  "webglGetUniformLocation",
  "webglPrepareUniformLocationsBeforeFirstUse",
  "webglGetLeftBracePos",
  "emscriptenWebGLGetVertexAttrib",
  "__glGetActiveAttribOrUniform",
  "writeGLArray",
  "registerWebGlEventCallback",
  "ALLOC_NORMAL",
  "ALLOC_STACK",
  "allocate",
  "writeStringToMemory",
  "writeAsciiToMemory",
  "setErrNo",
  "demangle",
  "stackTrace",
];
missingLibrarySymbols.forEach(missingLibrarySymbol);

var unexportedSymbols = [
  "run",
  "addOnPreRun",
  "addOnInit",
  "addOnPreMain",
  "addOnExit",
  "addOnPostRun",
  "out",
  "err",
  "abort",
  "wasmMemory",
  "wasmExports",
  "writeStackCookie",
  "checkStackCookie",
  "readI53FromI64",
  "convertI32PairToI53Checked",
  "stackSave",
  "stackRestore",
  "stackAlloc",
  "setTempRet0",
  "ptrToString",
  "zeroMemory",
  "exitJS",
  "getHeapMax",
  "growMemory",
  "ENV",
  "ERRNO_CODES",
  "strError",
  "DNS",
  "Protocols",
  "Sockets",
  "timers",
  "warnOnce",
  "readEmAsmArgsArray",
  "jstoi_s",
  "getExecutableName",
  "handleException",
  "keepRuntimeAlive",
  "runtimeKeepalivePush",
  "runtimeKeepalivePop",
  "callUserCallback",
  "maybeExit",
  "asyncLoad",
  "alignMemory",
  "mmapAlloc",
  "wasmTable",
  "noExitRuntime",
  "sigToWasmTypes",
  "freeTableIndexes",
  "functionsInTableMap",
  "setValue",
  "getValue",
  "PATH",
  "PATH_FS",
  "UTF8Decoder",
  "UTF8ArrayToString",
  "UTF8ToString",
  "stringToUTF8Array",
  "stringToUTF8",
  "lengthBytesUTF8",
  "intArrayFromString",
  "stringToAscii",
  "UTF16Decoder",
  "stringToUTF8OnStack",
  "JSEvents",
  "specialHTMLTargets",
  "findCanvasEventTarget",
  "currentFullscreenStrategy",
  "restoreOldWindowedStyle",
  "UNWIND_CACHE",
  "ExitStatus",
  "getEnvStrings",
  "checkWasiClock",
  "doReadv",
  "doWritev",
  "initRandomFill",
  "randomFill",
  "safeSetTimeout",
  "promiseMap",
  "uncaughtExceptionCount",
  "exceptionLast",
  "exceptionCaught",
  "ExceptionInfo",
  "findMatchingCatch",
  "Browser",
  "getPreloadedImageData__data",
  "wget",
  "MONTH_DAYS_REGULAR",
  "MONTH_DAYS_LEAP",
  "MONTH_DAYS_REGULAR_CUMULATIVE",
  "MONTH_DAYS_LEAP_CUMULATIVE",
  "SYSCALLS",
  "preloadPlugins",
  "FS_modeStringToFlags",
  "FS_getMode",
  "FS_stdin_getChar_buffer",
  "FS_stdin_getChar",
  "FS_readFile",
  "MEMFS",
  "TTY",
  "PIPEFS",
  "SOCKFS",
  "tempFixedLengthArray",
  "miniTempWebGLFloatBuffers",
  "miniTempWebGLIntBuffers",
  "GL",
  "AL",
  "GLUT",
  "EGL",
  "GLEW",
  "IDBStore",
  "runAndAbortIfError",
  "Asyncify",
  "Fibers",
  "SDL",
  "SDL_gfx",
  "WebGPU",
  "JsValStore",
  "allocateUTF8",
  "allocateUTF8OnStack",
  "print",
  "printErr",
];
unexportedSymbols.forEach(unexportedRuntimeSymbol);

var calledRun;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args = []) {
  assert(
    runDependencies == 0,
    'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])'
  );
  assert(
    __ATPRERUN__.length == 0,
    "cannot call main when preRun functions remain to be called"
  );

  var entryFunction = _main;

  args.unshift(thisProgram);

  var argc = args.length;
  var argv = stackAlloc((argc + 1) * 4);
  var argv_ptr = argv;
  args.forEach((arg) => {
    HEAPU32[argv_ptr >> 2] = stringToUTF8OnStack(arg);
    argv_ptr += 4;
  });
  HEAPU32[argv_ptr >> 2] = 0;

  try {
    var ret = entryFunction(argc, argv);

    // if we're not running an evented main loop, it's time to exit
    exitJS(ret, /* implicit = */ true);
    return ret;
  } catch (e) {
    return handleException(e);
  }
}

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run(args = arguments_) {
  if (runDependencies > 0) {
    return;
  }

  stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module["calledRun"] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    Module["onRuntimeInitialized"]?.();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module["setStatus"]) {
    Module["setStatus"]("Running...");
    setTimeout(() => {
      setTimeout(() => Module["setStatus"](""), 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  };
  try {
    // it doesn't matter if it fails
    _fflush(0);
    // also flush in the JS FS layer
    ["stdout", "stderr"].forEach((name) => {
      var info = FS.analyzePath("/dev/" + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty?.output?.length) {
        has = true;
      }
    });
  } catch (e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce(
      "stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc."
    );
  }
}

if (Module["preInit"]) {
  if (typeof Module["preInit"] == "function")
    Module["preInit"] = [Module["preInit"]];
  while (Module["preInit"].length > 0) {
    Module["preInit"].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = false;

if (Module["noInitialRun"]) shouldRunNow = false;

run();

// end include: postamble.js
```
